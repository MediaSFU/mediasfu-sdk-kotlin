package com.mediasfu.sdk.ui.mediasfu

import androidx.compose.animation.AnimatedVisibility
import androidx.compose.animation.core.TweenSpec
import androidx.compose.animation.fadeIn
import androidx.compose.animation.fadeOut
import androidx.compose.foundation.BorderStroke
import androidx.compose.foundation.ExperimentalFoundationApi
import androidx.compose.foundation.background
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Box
import androidx.compose.foundation.layout.BoxWithConstraints
import androidx.compose.foundation.layout.BoxScope
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.ExperimentalLayoutApi
import androidx.compose.foundation.layout.FlowRow
import androidx.compose.foundation.layout.PaddingValues
import androidx.compose.foundation.layout.Row
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.fillMaxWidth
import androidx.compose.foundation.layout.height
import androidx.compose.foundation.layout.heightIn
import androidx.compose.foundation.layout.padding
import androidx.compose.foundation.layout.size
import androidx.compose.foundation.layout.width
import androidx.compose.foundation.layout.widthIn
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.LazyRow
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.selection.selectable
import androidx.compose.foundation.selection.selectableGroup
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.automirrored.rounded.Chat
import androidx.compose.material.icons.automirrored.rounded.KeyboardArrowLeft
import androidx.compose.material.icons.automirrored.rounded.KeyboardArrowRight
import androidx.compose.material.icons.automirrored.rounded.Message
import androidx.compose.material.icons.automirrored.rounded.OpenInNew
import androidx.compose.material.icons.automirrored.rounded.ScreenShare
import androidx.compose.material.icons.automirrored.rounded.Send
import androidx.compose.material.icons.automirrored.rounded.StopScreenShare
import androidx.compose.material.icons.rounded.AccessTime
import androidx.compose.material.icons.rounded.ArrowDropDown
import androidx.compose.material.icons.rounded.ArrowDropUp
import androidx.compose.material.icons.rounded.Check
import androidx.compose.material.icons.rounded.Close
import androidx.compose.material.icons.rounded.ContentCopy
import androidx.compose.material.icons.rounded.Delete
import androidx.compose.material.icons.rounded.DisplaySettings
import androidx.compose.material.icons.rounded.Email
import androidx.compose.material.icons.rounded.FiberManualRecord
import androidx.compose.material.icons.rounded.Group
import androidx.compose.material.icons.rounded.HowToVote
import androidx.compose.material.icons.rounded.Menu
import androidx.compose.material.icons.rounded.Mic
import androidx.compose.material.icons.rounded.MicOff
import androidx.compose.material.icons.rounded.Person
import androidx.compose.material.icons.rounded.Public
import androidx.compose.material.icons.rounded.Settings
import androidx.compose.material.icons.rounded.Share
import androidx.compose.material.icons.rounded.SupervisorAccount
import androidx.compose.material.icons.rounded.VideoCall
import androidx.compose.material.icons.rounded.VideoCameraFront
import androidx.compose.material.icons.rounded.Videocam
import androidx.compose.material.icons.rounded.VideocamOff
import androidx.compose.material.icons.filled.FlipCameraAndroid
import androidx.compose.material3.AlertDialog
import androidx.compose.material3.Button
import androidx.compose.material3.ButtonDefaults
import androidx.compose.material3.Card
import androidx.compose.material3.CardDefaults
import androidx.compose.material3.CircularProgressIndicator
import androidx.compose.material3.Divider
import androidx.compose.material3.DropdownMenu
import androidx.compose.material3.DropdownMenuItem
import androidx.compose.material3.ElevatedCard
import androidx.compose.material3.ExperimentalMaterial3Api
import androidx.compose.material3.ExposedDropdownMenuBox
import androidx.compose.material3.ExposedDropdownMenuDefaults
import androidx.compose.material3.Icon
import androidx.compose.material3.IconButton
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.OutlinedButton
import androidx.compose.material3.OutlinedTextField
import androidx.compose.material3.RadioButton
import androidx.compose.material3.RadioButtonDefaults
import androidx.compose.material3.Surface
import androidx.compose.material3.Switch
import androidx.compose.material3.Text
import androidx.compose.material3.TextButton
import androidx.compose.runtime.*
import androidx.compose.runtime.snapshots.SnapshotStateList
import androidx.compose.runtime.snapshotFlow
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.layout.onGloballyPositioned
import androidx.compose.ui.platform.LocalClipboardManager
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.platform.LocalUriHandler
import androidx.compose.ui.semantics.Role
import androidx.compose.ui.text.AnnotatedString
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.text.style.TextOverflow
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.compose.ui.unit.toSize
import com.mediasfu.sdk.consumers.ComponentSizes
import com.mediasfu.sdk.consumers.DispStreamsOptions
import com.mediasfu.sdk.consumers.GeneratePageContentOptions
import com.mediasfu.sdk.consumers.GeneratePageContentParameters
import com.mediasfu.sdk.consumers.GridSizes
import com.mediasfu.sdk.consumers.PrepopulateUserMediaOptions
import com.mediasfu.sdk.consumers.ScreenState
import com.mediasfu.sdk.consumers.ReorderStreamsOptions
import com.mediasfu.sdk.consumers.generatePageContent
import com.mediasfu.sdk.consumers.updateMiniCardsGridImpl
import com.mediasfu.sdk.methods.MediasfuParameters
import com.mediasfu.sdk.methods.breakout_rooms_methods.BreakoutRoomUpdatedData as BreakoutData
import com.mediasfu.sdk.methods.breakout_rooms_methods.BreakoutRoomUpdatedOptions
import com.mediasfu.sdk.methods.breakout_rooms_methods.breakoutRoomUpdated
import com.mediasfu.sdk.methods.exit_methods.ConfirmExitOptions
import com.mediasfu.sdk.methods.exit_methods.confirmExit
import com.mediasfu.sdk.methods.menu_methods.LaunchMenuModalOptions
import com.mediasfu.sdk.methods.menu_methods.launchMenuModal
import com.mediasfu.sdk.methods.message_methods.SendMessageOptions
import com.mediasfu.sdk.methods.message_methods.sendMessage
import com.mediasfu.sdk.methods.polls_methods.HandleCreatePollOptions
import com.mediasfu.sdk.methods.polls_methods.HandleEndPollOptions
import com.mediasfu.sdk.methods.polls_methods.HandleVotePollOptions
import com.mediasfu.sdk.methods.polls_methods.LaunchPollOptions
import com.mediasfu.sdk.methods.polls_methods.PollUpdatedOptions
import com.mediasfu.sdk.methods.polls_methods.handleCreatePoll
import com.mediasfu.sdk.methods.polls_methods.handleEndPoll
import com.mediasfu.sdk.methods.polls_methods.handleVotePoll
import com.mediasfu.sdk.methods.polls_methods.launchPoll
import com.mediasfu.sdk.methods.polls_methods.pollUpdated
import com.mediasfu.sdk.methods.recording_methods.ConfirmRecordingOptions as MethodConfirmRecordingOptions
import com.mediasfu.sdk.methods.recording_methods.LaunchRecordingOptions
import com.mediasfu.sdk.methods.recording_methods.StartRecordingOptions as MethodStartRecordingOptions
import com.mediasfu.sdk.methods.recording_methods.confirmRecording
import com.mediasfu.sdk.methods.recording_methods.launchRecording
import com.mediasfu.sdk.methods.recording_methods.startRecording
import com.mediasfu.sdk.methods.requests_methods.LaunchRequestsOptions
import com.mediasfu.sdk.methods.requests_methods.RespondToRequestsOptions
import com.mediasfu.sdk.methods.requests_methods.launchRequests
import com.mediasfu.sdk.methods.requests_methods.respondToRequests
import com.mediasfu.sdk.methods.participants_methods.RemoveParticipantsOptions
import com.mediasfu.sdk.methods.participants_methods.removeParticipants
import com.mediasfu.sdk.methods.media_settings_methods.LaunchMediaSettingsOptions
import com.mediasfu.sdk.methods.media_settings_methods.launchMediaSettings
import com.mediasfu.sdk.methods.co_host_methods.ModifyCoHostSettingsOptions
import com.mediasfu.sdk.methods.co_host_methods.modifyCoHostSettings
import com.mediasfu.sdk.methods.stream_methods.ClickAudioOptions
import com.mediasfu.sdk.methods.stream_methods.ClickScreenShareOptions
import com.mediasfu.sdk.methods.stream_methods.ClickVideoOptions
import com.mediasfu.sdk.methods.stream_methods.clickAudio
import com.mediasfu.sdk.methods.stream_methods.clickScreenShare
import com.mediasfu.sdk.methods.stream_methods.clickVideo
import com.mediasfu.sdk.methods.stream_methods.switchAudio
import com.mediasfu.sdk.methods.stream_methods.switchVideo
import com.mediasfu.sdk.methods.stream_methods.switchVideoAlt
import com.mediasfu.sdk.methods.utils.CreateResponseJoinRoomOptions
import com.mediasfu.sdk.methods.utils.createResponseJoinRoom
import com.mediasfu.sdk.methods.utils.producer.ProducerOptionsType
import com.mediasfu.sdk.methods.waiting_methods.LaunchWaitingOptions
import com.mediasfu.sdk.methods.waiting_methods.RespondToWaitingOptions
import com.mediasfu.sdk.methods.waiting_methods.launchWaiting
import com.mediasfu.sdk.methods.waiting_methods.respondToWaiting
import com.mediasfu.sdk.model.*
import com.mediasfu.sdk.model.BreakoutParticipant as ModelBreakoutParticipant
import com.mediasfu.sdk.model.CoHostResponsibility as ModelCoHostResponsibility
import com.mediasfu.sdk.model.SeedData as ModelSeedData
import com.mediasfu.sdk.network.mediaSfuJson
import com.mediasfu.sdk.producer_client.JoinRoomClientOptions
import com.mediasfu.sdk.producer_client.UpdateRoomParametersClientOptions
import com.mediasfu.sdk.producer_client.UpdateRoomParametersClientParameters
import com.mediasfu.sdk.producer_client.joinRoomClient
import com.mediasfu.sdk.producer_client.updateRoomParametersClient
import com.mediasfu.sdk.producer_client.*
import com.mediasfu.sdk.socket.JoinLocalRoomOptions
import com.mediasfu.sdk.socket.ResponseJoinLocalRoom
import com.mediasfu.sdk.socket.ResponseJoinRoom
import com.mediasfu.sdk.socket.SocketManager
import com.mediasfu.sdk.socket.allMembers
import com.mediasfu.sdk.socket.allMembersRest
import com.mediasfu.sdk.socket.allWaitingRoomMembers
import com.mediasfu.sdk.socket.disconnect
import com.mediasfu.sdk.socket.joinLocalRoom
import com.mediasfu.sdk.socket.MeetingEndedOptions as SocketMeetingEndedOptions
import com.mediasfu.sdk.socket.MeetingStillThereOptions as SocketMeetingStillThereOptions
import com.mediasfu.sdk.socket.MeetingTimeRemainingOptions as SocketMeetingTimeRemainingOptions
import com.mediasfu.sdk.socket.ParticipantRequestedOptions as SocketParticipantRequestedOptions
import com.mediasfu.sdk.socket.PersonJoinedOptions as SocketPersonJoinedOptions
import com.mediasfu.sdk.socket.ReceiveMessageOptions as SocketReceiveMessageOptions
import com.mediasfu.sdk.socket.*
import com.mediasfu.sdk.model.MediaDeviceInfo as ModelMediaDeviceInfo
import com.mediasfu.sdk.ui.components.cohost.CoHostModalOptions
import com.mediasfu.sdk.ui.components.cohost.CoHostResponsibility as UiCoHostResponsibility
import com.mediasfu.sdk.ui.components.display_settings.DisplaySettingsModalOptions
import com.mediasfu.sdk.ui.components.display_settings.DisplaySettingsModalParameters
import com.mediasfu.sdk.ui.components.event_settings.EventSettingsModalOptions
import com.mediasfu.sdk.ui.components.event_settings.ModifySettingsOptions
import com.mediasfu.sdk.ui.components.media_settings.MediaSettingsModalOptions
import com.mediasfu.sdk.ui.components.media_settings.MediaSettingsModalParameters
import com.mediasfu.sdk.ui.components.media_settings.MediaDeviceInfo as UiMediaDeviceInfo
import com.mediasfu.sdk.ui.components.media_settings.SwitchAudioOptions as UiSwitchAudioOptions
import com.mediasfu.sdk.ui.components.media_settings.SwitchVideoAltOptions as UiSwitchVideoAltOptions
import com.mediasfu.sdk.ui.components.media_settings.SwitchVideoOptions as UiSwitchVideoOptions
import com.mediasfu.sdk.ui.components.breakout.BreakoutParticipant as UiBreakoutParticipant
import com.mediasfu.sdk.ui.components.breakout.BreakoutRoomsModalOptions
import com.mediasfu.sdk.ui.components.breakout.BreakoutRoomsModalParameters
import com.mediasfu.sdk.ui.components.display.*
import com.mediasfu.sdk.ui.components.ControlButtonOptions
import com.mediasfu.sdk.ui.ComponentStyle
import com.mediasfu.sdk.webrtc.WebRtcDevice
import kotlin.math.ceil
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Job
import kotlinx.coroutines.delay
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.flow.combine
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import kotlinx.coroutines.runBlocking
import kotlinx.datetime.Instant
import kotlinx.datetime.TimeZone
import kotlinx.datetime.toLocalDateTime
import kotlinx.serialization.json.JsonElement
import kotlinx.serialization.json.JsonNull
import kotlinx.serialization.json.JsonObject
import kotlinx.serialization.json.JsonPrimitive
import kotlinx.serialization.json.add
import kotlinx.serialization.json.buildJsonArray
import kotlinx.serialization.json.buildJsonObject
import kotlinx.serialization.json.decodeFromJsonElement
import kotlinx.serialization.json.jsonObject
import kotlinx.serialization.json.put
import kotlin.math.roundToInt
import kotlin.math.sqrt

private const val CONFIRM_HERE_COUNTDOWN_SECONDS = 60

private val seedNameSanitizer = Regex("[^a-z0-9]+")

// Provides demo data so development builds render without a live session.
private fun defaultSeedData(): ModelSeedData {
    val participants = listOf(
        Participant(
            id = "host-1",
            audioID = "audio-host-1",
            videoID = "video-host-1",
            islevel = "2",
            isHost = true,
            name = "Alex Morgan",
            muted = false,
            videoOn = true,
            audioOn = true
        ),
        Participant(
            id = "speaker-1",
            audioID = "audio-speaker-1",
            videoID = "video-speaker-1",
            islevel = "1",
            name = "Jordan Lee",
            muted = false,
            videoOn = true,
            audioOn = true
        ),
        Participant(
            id = "speaker-2",
            audioID = "audio-speaker-2",
            videoID = "video-speaker-2",
            islevel = "1",
            name = "Morgan Patel",
            muted = true,
            videoOn = true,
            audioOn = false
        ),
        Participant(
            id = "listener-1",
            audioID = "audio-listener-1",
            videoID = "video-listener-1",
            islevel = "0",
            name = "Riley Chen",
            muted = false,
            videoOn = false,
            audioOn = true
        )
    )

    return ModelSeedData(
        member = "Alex Morgan",
        host = "Alex Morgan",
        eventType = EventType.CONFERENCE,
        participants = participants,
        messages = listOf(
            Message(
                sender = "Alex Morgan",
                receivers = listOf("Everyone"),
                message = "Welcome to the MediaSFU demo session!",
                timestamp = "09:58",
                group = true
            ),
            Message(
                sender = "Jordan Lee",
                receivers = listOf("Everyone"),
                message = "Good morning all!",
                timestamp = "09:59",
                group = true
            )
        ),
        polls = listOf(
            Poll(
                id = "poll-1",
                question = "How is the call quality?",
                type = "singleChoice",
                options = listOf("Great", "Okay", "Needs work"),
                votes = listOf(8, 2, 0),
                status = "live"
            )
        ),
        breakoutRooms = listOf(
            listOf(participants[1], participants[2]),
            listOf(participants[3])
        ),
        requests = listOf(
            Request(id = "req-1", icon = "hand", name = "Jamie Alvarez", username = "jamie")
        ),
        waitingList = listOf(
            WaitingRoomParticipant(name = "Taylor Kim", id = "waiting-1")
        )
    )
}

private fun buildSeedStreams(participants: List<Participant>): List<Stream> {
    return participants.mapIndexed { index, participant ->
        val fallbackId = "participant-${index + 1}"
        val baseId = participant.id?.takeIf { it.isNotBlank() }
            ?: participant.name.lowercase().replace(seedNameSanitizer, "-").trim('-').ifBlank { fallbackId }
        val audioId = participant.audioID.ifBlank { "audio-$baseId" }
        val videoId = participant.videoID.ifBlank { "video-$baseId" }

        Stream(
            id = videoId,
            producerId = videoId,
            muted = !participant.audioOn,
            name = participant.name,
            audioID = audioId,
            videoID = videoId
        )
    }
}

private fun buildPlaceholderStreams(participants: List<Participant>): List<Stream> {
    if (participants.isEmpty()) return emptyList()

    return participants.mapIndexed { index, participant ->
        val fallbackId = "placeholder-${index + 1}"
        val baseId = participant.id?.takeIf { it.isNotBlank() }
            ?: participant.name.lowercase().replace(seedNameSanitizer, "-").trim('-').ifBlank { fallbackId }
        val audioId = participant.audioID.ifBlank { "audio-$baseId" }
        val videoId = participant.videoID.ifBlank { "video-$baseId" }

        Stream(
            id = videoId,
            producerId = videoId,
            muted = !participant.audioOn,
            name = participant.name,
            audioID = audioId,
            videoID = videoId,
            extra = buildJsonObject {
                put("placeholder", JsonPrimitive(true))
                put("participantName", JsonPrimitive(participant.name))
            }
        )
    }
}

class MediasfuGenericState internal constructor(
    private val scope: CoroutineScope,
    internal val parameters: MediasfuParameters,
    internal val options: MediasfuGenericOptions,
) {
    private val _validated = MutableStateFlow(parameters.validated)
    val validated: StateFlow<Boolean> = _validated.asStateFlow()

    private val _isLoading = MutableStateFlow(false)
    val isLoading: StateFlow<Boolean> = _isLoading.asStateFlow()

    private val _orientation = MutableStateFlow("landscape")
    val orientation: StateFlow<String> = _orientation.asStateFlow()

    val connectivity = ConnectivityState(parameters, ::notifyParametersChanged)
    val room = RoomState(parameters, ::notifyParametersChanged)
    val media = MediaState(parameters, ::notifyParametersChanged)
    val display = DisplayState(parameters, ::notifyParametersChanged)
    val streams = StreamsState(parameters, ::notifyParametersChanged)
    private val pageContentParameters = MediasfuPageContentParameters(parameters, this)
    val recording = RecordingState(parameters, ::notifyParametersChanged)
    val meeting = MeetingState(scope, parameters, ::notifyParametersChanged)
    val messaging = MessagingState(parameters, ::notifyParametersChanged)
    val waitingRoom = WaitingRoomState(parameters, ::notifyParametersChanged)
    val requests = RequestsState(parameters, ::notifyParametersChanged)
    val polls = PollsState(parameters, ::notifyParametersChanged)
    val breakout = BreakoutState(parameters, ::notifyParametersChanged)
    val modals = ModalState(parameters, ::notifyParametersChanged, scope)
    val alert = AlertState(parameters)
    private val coroutineScope: CoroutineScope
        get() = scope

    fun toggleMediaSettings() = modals.toggleMediaSettings()
    fun toggleDisplaySettings() = modals.toggleDisplaySettings()
    fun toggleCoHost() = modals.toggleCoHost()
    fun toggleBreakoutRooms() = modals.toggleBreakoutRooms()

    private fun ModelCoHostResponsibility.toUi(): UiCoHostResponsibility =
        UiCoHostResponsibility(name = name, value = value, dedicated = dedicated)

    private fun UiCoHostResponsibility.toModel(): ModelCoHostResponsibility =
        ModelCoHostResponsibility(name = name, value = value, dedicated = dedicated)

    private fun List<ModelCoHostResponsibility>.toUiList(): List<UiCoHostResponsibility> =
        map { it.toUi() }

    private fun List<UiCoHostResponsibility>.toModelList(): List<ModelCoHostResponsibility> =
        map { it.toModel() }

    private fun ModelBreakoutParticipant.toUi(): UiBreakoutParticipant =
        UiBreakoutParticipant(name = name, breakRoom = breakRoom)

    private fun UiBreakoutParticipant.toModel(): ModelBreakoutParticipant =
        ModelBreakoutParticipant(name = name, breakRoom = breakRoom)

    private fun List<List<ModelBreakoutParticipant>>.toUiRooms(): List<List<UiBreakoutParticipant>> =
        map { room -> room.map { it.toUi() } }

    private fun List<List<UiBreakoutParticipant>>.toModelRooms(): List<List<ModelBreakoutParticipant>> =
        map { room -> room.map { it.toModel() } }

    private var autoJoinJob: Job? = null
    private var seedApplied = false
    private val socketEventNames = mutableSetOf<String>()
    private var registeredSocket: SocketManager? = null
    private var initialMediaHydrated = false

    init {
        applyInitialOptions()
        parameters.onParticipantsUpdated = { updated -> handleParticipantsUpdated(updated) }
        observeOrientationChanges()
        observeAutoJoinTriggers()
        observeSocketConnections()
    }

    private fun observeOrientationChanges() {
        scope.launch {
            snapshotFlow { media.screenAlreadyOn }.collectLatest { screenOn ->
                _orientation.value = if (screenOn) "landscape" else media.targetOrientation
            }
        }
    }

    private fun observeAutoJoinTriggers() {
        scope.launch {
            combine(
                validated,
                snapshotFlow { connectivity.socket },
                snapshotFlow { connectivity.roomResponse },
            ) { isValidated, socket, response ->
                Triple(isValidated, socket, response)
            }.collectLatest { (isValidated, socket, response) ->
                if (!isValidated || socket == null) {
                    autoJoinJob?.cancel()
                    autoJoinJob = null
                    return@collectLatest
                }
                if (response.success == true) {
                    autoJoinJob?.cancel()
                    autoJoinJob = null
                    return@collectLatest
                }
                attemptAutoJoin()
            }
        }
    }

    private fun observeSocketConnections() {
        scope.launch {
            snapshotFlow { connectivity.socket }.collectLatest { socket ->
                if (registeredSocket === socket) return@collectLatest

                clearSocketListeners(registeredSocket)
                registeredSocket = socket

                if (socket != null) {
                    setupSocketListeners(socket)
                }
            }
        }
    }

    private fun handleParticipantsUpdated(updated: List<Participant>) {
        room.refreshFromParameters()

        println(
            "MediaSFU - handleParticipantsUpdated: size=${updated.size} validated=${_validated.value} " +
                "initialMediaHydrated=$initialMediaHydrated"
        )

        if (!_validated.value || updated.isEmpty() || initialMediaHydrated) {
            println("MediaSFU - handleParticipantsUpdated: skipped hydration")
            return
        }

        initialMediaHydrated = true

        scope.launch {
            println("MediaSFU - handleParticipantsUpdated: triggering initializeMediaStateAfterValidation")
            initializeMediaStateAfterValidation(
                defaultMemberName = room.member.ifBlank { resolveApiUserName() }
            )

            if (parameters.participants.isEmpty()) {
                println("MediaSFU - handleParticipantsUpdated: participants cleared, resetting hydration flag")
                initialMediaHydrated = false
            }
        }
    }

    private fun clearSocketListeners(socket: SocketManager?) {
        socketEventNames.forEach { event ->
            runCatching { socket?.off(event) }
        }
        socketEventNames.clear()
    }

    private fun setupSocketListeners(socket: SocketManager) {
        println("MediaSFU - setupSocketListeners: Setting up socket event listeners")
        println("MediaSFU - setupSocketListeners: Socket connected = ${socket.isConnected()}")
        
        registerSocketListener(socket, "disconnect") {
            scope.launch {
                handleDisconnectEvent()
            }
        }

        registerSocketListener(socket, "allMembers") { payload ->
            scope.launch {
                handleAllMembersEvent(payload)
            }
        }

        registerSocketListener(socket, "allMembersRest") { payload ->
            scope.launch {
                handleAllMembersRestEvent(payload)
            }
        }

        registerSocketListener(socket, "userWaiting") { payload ->
            scope.launch {
                handleUserWaitingEvent(payload)
            }
        }

        registerSocketListener(socket, "personJoined") { payload ->
            scope.launch {
                handlePersonJoinedEvent(payload)
            }
        }

        registerSocketListener(socket, "allWaitingRoomMembers") { payload ->
            scope.launch {
                handleAllWaitingRoomMembersEvent(payload)
            }
        }

        registerSocketListener(socket, "participantRequested") { payload ->
            scope.launch {
                handleParticipantRequestedEvent(payload)
            }
        }

        registerSocketListener(socket, "meetingEnded") { payload ->
            scope.launch {
                handleMeetingEndedEvent(payload)
            }
        }

        registerSocketListener(socket, "ban") { payload ->
            scope.launch {
                handleBanEvent(payload)
            }
        }

        registerSocketListener(socket, "updatedCoHost") { payload ->
            scope.launch {
                handleUpdatedCoHostEvent(payload)
            }
        }

        registerSocketListener(socket, "screenProducerId") { payload ->
            scope.launch {
                handleScreenProducerIdEvent(payload)
            }
        }

        registerSocketListener(socket, "updateMediaSettings") { payload ->
            scope.launch {
                handleUpdateMediaSettingsEvent(payload)
            }
        }

        registerSocketListener(socket, "producer-media-paused") { payload ->
            scope.launch {
                handleProducerMediaPausedEvent(payload)
            }
        }

        registerSocketListener(socket, "producer-media-resumed") { payload ->
            scope.launch {
                handleProducerMediaResumedEvent(payload)
            }
        }

        registerSocketListener(socket, "producer-media-closed") { payload ->
            scope.launch {
                handleProducerMediaClosedEvent(payload)
            }
        }

        registerSocketListener(socket, "controlMediaHost") { payload ->
            scope.launch {
                handleControlMediaHostEvent(payload)
            }
        }

        registerSocketListener(socket, "disconnectUserSelf") { payload ->
            scope.launch {
                handleDisconnectUserSelfEvent(payload)
            }
        }

        registerSocketListener(socket, "receiveMessage") { payload ->
            scope.launch {
                handleReceiveMessageEvent(payload)
            }
        }

        registerSocketListener(socket, "meetingTimeRemaining") { payload ->
            scope.launch {
                handleMeetingTimeRemainingEvent(payload)
            }
        }

        registerSocketListener(socket, "meetingStillThere") { payload ->
            scope.launch {
                handleMeetingStillThereEvent(payload)
            }
        }

        registerSocketListener(socket, "updateConsumingDomains") { payload ->
            scope.launch {
                handleUpdateConsumingDomainsEvent(payload)
            }
        }

        registerSocketListener(socket, "hostRequestResponse") { payload ->
            scope.launch {
                handleHostRequestResponseEvent(payload)
            }
        }

        registerSocketListener(socket, "pollUpdated") { payload ->
            scope.launch {
                handlePollUpdatedEvent(payload)
            }
        }

        registerSocketListener(socket, "breakoutRoomUpdated") { payload ->
            scope.launch {
                handleBreakoutRoomUpdatedEvent(payload)
            }
        }

        // Recording-related events (typically on socketAlt in Flutter)
        registerSocketListener(socket, "roomRecordParams") { payload ->
            scope.launch {
                handleRoomRecordParamsEvent(payload)
            }
        }

        registerSocketListener(socket, "startRecords") { payload ->
            scope.launch {
                handleStartRecordsEvent(payload)
            }
        }

        registerSocketListener(socket, "reInitiateRecording") { payload ->
            scope.launch {
                handleReInitiateRecordingEvent(payload)
            }
        }

        registerSocketListener(socket, "RecordingNotice") { payload ->
            scope.launch {
                handleRecordingNoticeEvent(payload)
            }
        }

        registerSocketListener(socket, "timeLeftRecording") { payload ->
            scope.launch {
                handleTimeLeftRecordingEvent(payload)
            }
        }

        registerSocketListener(socket, "stoppedRecording") { payload ->
            scope.launch {
                handleStoppedRecordingEvent(payload)
            }
        }
    }

    private fun registerSocketListener(
        socket: SocketManager,
        event: String,
        handler: suspend (Map<String, Any?>) -> Unit
    ) {
        socketEventNames.add(event)
        socket.on(event) { data ->
            println("MediaSFU - Socket Event Received: '$event'")
            scope.launch { handler(data) }
        }
    }

    private suspend fun handleDisconnectEvent() {
        val alertCallback = ShowAlert { message, type, duration ->
            showAlert(message, type, duration)
        }

        disconnect(
            DisconnectOptions(
                showAlert = alertCallback,
                redirectUrl = null,
                onWeb = false,
                updateValidated = ::updateValidated
            )
        )

        parameters.reset()
        propagateParameterChanges()
    }

    private suspend fun handleAllMembersEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<AllMembersData>()
        
        if (data == null) {
            println("MediaSFU - handleAllMembersEvent: Failed to decode AllMembersData")
            return
        }

        val options = AllMembersOptions(
            members = data.members,
            requests = data.requests,
            settings = data.settings,
            coHost = data.coHost ?: room.coHost,
            coHostRes = data.coHostResponsibilities,
            parameters = createAllMembersParameters(),
            consumeSockets = parameters.consumeSocketsState,
            apiUserName = resolveApiUserName(),
            apiKey = room.apiKey.takeIf { it.isNotBlank() },
            apiToken = room.apiToken
        )

        allMembers(options)
        propagateParameterChanges()
    }

    private suspend fun handleAllMembersRestEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<AllMembersRestData>()
        
        if (data == null) {
            println("MediaSFU - handleAllMembersRestEvent: Failed to decode AllMembersRestData")
            return
        }

        val options = AllMembersRestOptions(
            members = data.members,
            settings = data.settings,
            coHost = data.coHost ?: room.coHost,
            coHostRes = data.coHostResponsibilities,
            parameters = createAllMembersRestParameters(),
            consumeSockets = parameters.consumeSocketsState,
            apiUserName = resolveApiUserName(),
            apiKey = room.apiKey.takeIf { it.isNotBlank() },
            apiToken = room.apiToken
        )

        allMembersRest(options)
    }

    private suspend fun handleUserWaitingEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<UserWaitingData>() ?: return
        val name = data.name ?: return

        val options = UserWaitingOptions(
            name = name,
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            },
            totalReqWait = requests.totalPending,
            updateTotalReqWait = requests::updateTotalPending
        )

        userWaiting(options)
    }

    private suspend fun handlePersonJoinedEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<PersonJoinedData>() ?: return
        val name = data.name ?: return

    val options = SocketPersonJoinedOptions(
            name = name,
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            }
        )

        personJoined(options)
    }

    private suspend fun handleAllWaitingRoomMembersEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<AllWaitingRoomMembersData>()

        val participants = when {
            data == null -> null
            !data.waitingParticipants.isNullOrEmpty() -> data.waitingParticipants
            !data.waitingParticipantss.isNullOrEmpty() -> data.waitingParticipantss
            else -> null
        }

        val resolvedParticipants = participants ?: waitingRoom.waitingRoomList.toList()

        val options = AllWaitingRoomMembersOptions(
            waitingParticipants = resolvedParticipants,
            updateWaitingRoomList = waitingRoom::updateList,
            updateTotalReqWait = requests::updateTotalPending
        )

        allWaitingRoomMembers(options)
        propagateParameterChanges()
    }

    private suspend fun handleParticipantRequestedEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<ParticipantRequestedData>() ?: return
        val request = data.userRequest ?: return

        val currentRequests = requests.requests.toList()
        val waitingParticipants = waitingRoom.waitingRoomList.toList()

    val options = SocketParticipantRequestedOptions(
            userRequest = request,
            requestList = currentRequests,
            waitingRoomList = waitingParticipants,
            updateTotalReqWait = requests::updateTotalPending,
            updateRequestList = requests::updateList
        )

        participantRequested(options)
        propagateParameterChanges()
    }

    private suspend fun handleMeetingEndedEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<MeetingEndedData>()

        fun parseBoolean(raw: Any?): Boolean? = when (raw) {
            is Boolean -> raw
            is Number -> raw.toInt() != 0
            is String -> raw.equals("true", ignoreCase = true) || raw == "1"
            else -> null
        }

        fun parseEventType(raw: Any?): EventType? = when (raw) {
            is EventType -> raw
            is String -> runCatching { EventType.valueOf(raw.trim().uppercase()) }.getOrNull()
            else -> null
        }

        val redirectUrl = data?.redirectUrl
            ?: payload["redirectURL"] as? String
            ?: payload["redirect_url"] as? String

        val onWeb = data?.onWeb
            ?: parseBoolean(payload["onWeb"])
            ?: parseBoolean(payload["onweb"])
            ?: false

        val eventType = data?.eventType
            ?: parseEventType(payload["eventType"])
            ?: parseEventType(payload["event_type"])
            ?: room.eventType

    val options = SocketMeetingEndedOptions(
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            },
            redirectUrl = redirectUrl,
            onWeb = onWeb,
            eventType = eventType,
            updateValidated = ::updateValidated
        )

        meeting.stopTimer(reset = true)
        meeting.hide()

        meetingEnded(options)
        propagateParameterChanges()
    }

    private suspend fun handleBanEvent(payload: Map<String, Any?>) {
        val name = payload["name"] as? String ?: return

        val options = BanParticipantOptions(
            name = name,
            parameters = parameters
        )

        banParticipant(options)
        propagateParameterChanges()
    }

    private suspend fun handleUpdatedCoHostEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<UpdatedCoHostData>()
        if (data == null) {
            println("MediaSFU - handleUpdatedCoHostEvent: Failed to decode UpdatedCoHostData")
            return
        }

        val options = UpdatedCoHostOptions(
            coHost = data.coHost ?: room.coHost,
            coHostResponsibility = data.coHostResponsibilities,
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            },
            eventType = room.eventType,
            islevel = room.islevel,
            member = room.member,
            youAreCoHost = room.youAreCoHost,
            updateCoHost = room::updateCoHost,
            updateCoHostResponsibility = room::updateCoHostResponsibility,
            updateYouAreCoHost = { newValue -> 
                room.youAreCoHost = newValue
                parameters.youAreCoHost = newValue
                notifyParametersChanged()
            }
        )

        updatedCoHost(options)
        propagateParameterChanges()
    }

    private suspend fun handleScreenProducerIdEvent(payload: Map<String, Any?>) {
        val producerId = payload["producerId"] as? String ?: return

        val options = ScreenProducerIdOptions(
            producerId = producerId,
            screenId = parameters.screenId,
            membersReceived = parameters.membersReceived,
            shareScreenStarted = parameters.shareScreenStarted,
            deferScreenReceived = parameters.deferScreenReceived,
            participants = room.participants.toList(),
            updateScreenId = parameters::updateScreenId,
            updateShareScreenStarted = parameters::updateShareScreenStarted,
            updateDeferScreenReceived = parameters::updateDeferScreenReceived
        )

        screenProducerId(options)
        propagateParameterChanges()
    }

    private suspend fun handleUpdateMediaSettingsEvent(payload: Map<String, Any?>) {
        val settingsList = payload["settings"] as? List<*> ?: return
        val settings = settingsList.mapNotNull { it as? String }

        val options = UpdateMediaSettingsOptions(
            settings = settings,
            updateAudioSetting = room::updateAudioSetting,
            updateVideoSetting = room::updateVideoSetting,
            updateScreenshareSetting = room::updateScreenshareSetting,
            updateChatSetting = room::updateChatSetting
        )

        updateMediaSettings(options)
        propagateParameterChanges()
    }

    private suspend fun handleProducerMediaPausedEvent(payload: Map<String, Any?>) {
        val producerId = payload["producerId"] as? String ?: return
        val kind = payload["kind"] as? String ?: return
        val name = payload["name"] as? String ?: ""

        val options = ProducerMediaPausedOptions(
            producerId = producerId,
            kind = kind,
            name = name,
            parameters = parameters
        )

        producerMediaPaused(options)
        propagateParameterChanges()
    }

    private suspend fun handleProducerMediaResumedEvent(payload: Map<String, Any?>) {
        val kind = payload["kind"] as? String ?: return
        val name = payload["name"] as? String ?: ""

        val options = ProducerMediaResumedOptions(
            kind = kind,
            name = name,
            parameters = parameters
        )

        producerMediaResumed(options)
        propagateParameterChanges()
    }

    private suspend fun handleProducerMediaClosedEvent(payload: Map<String, Any?>) {
        val producerId = payload["producerId"] as? String ?: return
        val kind = payload["kind"] as? String ?: return

        val options = ProducerMediaClosedOptions(
            producerId = producerId,
            kind = kind,
            parameters = parameters
        )

        producerMediaClosed(options)
        propagateParameterChanges()
    }

    private suspend fun handleControlMediaHostEvent(payload: Map<String, Any?>) {
        val type = payload["type"] as? String ?: return

        val options = ControlMediaHostOptions(
            type = type,
            parameters = parameters
        )

        controlMediaHost(options)
        propagateParameterChanges()
    }

    private suspend fun handleDisconnectUserSelfEvent(payload: Map<String, Any?>) {
        val socket = connectivity.socket ?: return
        
        val options = DisconnectUserSelfOptions(
            socket = socket.toSocketLike(),
            member = room.member,
            roomName = room.roomName,
            localSocket = null
        )

        disconnectUserSelf(options)
    }

    private suspend fun handleReceiveMessageEvent(payload: Map<String, Any?>) {
        val messageMap = payload["message"] as? Map<String, Any?> ?: return
        val message = Message.fromMap(messageMap)

        val options = SocketReceiveMessageOptions(
            message = message,
            messages = messaging.messages.toList(),
            participantsAll = room.participants.toList(),
            member = room.member,
            eventType = room.eventType,
            isLevel = room.islevel,
            coHost = room.coHost,
            updateMessages = messaging::updateMessages,
            updateShowMessagesBadge = messaging::updateShowMessagesBadge
        )

        receiveMessage(options)
        propagateParameterChanges()
    }

    private suspend fun handleMeetingTimeRemainingEvent(payload: Map<String, Any?>) {
        val timeRemaining = payload["timeRemaining"] as? Int ?: return

        val options = SocketMeetingTimeRemainingOptions(
            timeRemainingMillis = timeRemaining,
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            },
            eventType = room.eventType
        )

        meetingTimeRemaining(options)
    }

    private suspend fun handleMeetingStillThereEvent(payload: Map<String, Any?>) {
        val options = SocketMeetingStillThereOptions(
            updateIsConfirmHereModalVisible = modals::updateIsConfirmHereModalVisible
        )

        meetingStillThere(options)
        propagateParameterChanges()
    }

    private suspend fun handleUpdateConsumingDomainsEvent(payload: Map<String, Any?>) {
        val data = payload.decodePayload<UpdateConsumingDomainsData>() ?: return

        val options = UpdateConsumingDomainsOptions(
            domains = data.domains,
            altDomains = data.altDomains,
            apiUserName = resolveApiUserName(),
            apiToken = room.apiToken,
            apiKey = room.apiKey.takeIf { it.isNotBlank() } ?: "",
            parameters = parameters
        )

        updateConsumingDomains(options)
        propagateParameterChanges()
    }

    private suspend fun handleHostRequestResponseEvent(payload: Map<String, Any?>) {
        val requestResponseMap = payload["requestResponse"] as? Map<String, Any?> ?: return
        val requestResponse = RequestResponse.fromMap(requestResponseMap)

        val options = HostRequestResponseOptions(
            requestResponse = requestResponse,
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            },
            requestList = requests.requests,
            updateRequestList = requests::updateList,
            updateMicAction = requests::updateMicAction,
            updateVideoAction = requests::updateVideoAction,
            updateScreenAction = requests::updateScreenAction,
            updateChatAction = requests::updateChatAction,
            updateAudioRequestState = requests::updateAudioRequestState,
            updateVideoRequestState = requests::updateVideoRequestState,
            updateScreenRequestState = requests::updateScreenRequestState,
            updateChatRequestState = requests::updateChatRequestState,
            updateAudioRequestTime = requests::updateAudioRequestTime,
            updateVideoRequestTime = requests::updateVideoRequestTime,
            updateScreenRequestTime = requests::updateScreenRequestTime,
            updateChatRequestTime = requests::updateChatRequestTime,
            updateRequestIntervalSeconds = parameters.updateRequestIntervalSeconds
        )

        hostRequestResponse(options)
        propagateParameterChanges()
    }

    private suspend fun handlePollUpdatedEvent(payload: Map<String, Any?>) {
        val data = PollUpdatedData.fromMap(payload)

        val options = PollUpdatedOptions(
            data = data,
            polls = polls.polls,
            poll = polls.poll,
            member = room.member,
            islevel = room.islevel,
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            },
            updatePolls = polls::updatePolls,
            updatePoll = polls::updatePoll,
            updateIsPollModalVisible = modals::updateIsPollModalVisible
        )

        pollUpdated(options)
        propagateParameterChanges()
    }

    private suspend fun handleBreakoutRoomUpdatedEvent(payload: Map<String, Any?>) {
        val coreData = BreakoutRoomUpdatedData.fromMap(payload)
        
        // Convert to breakout_rooms_methods version
        val data = BreakoutData(
            forHost = coreData.forHost,
            newRoom = coreData.newRoom,
            members = coreData.members,
            breakoutRooms = coreData.breakoutRooms,
            status = coreData.status
        )

        val options = BreakoutRoomUpdatedOptions(
            data = data,
            parameters = parameters
        )

        breakoutRoomUpdated(options)
        propagateParameterChanges()
    }

    private suspend fun handleRoomRecordParamsEvent(payload: Map<String, Any?>) {
        val recordParams = RecordParameters.fromMap(payload)
        
        // Convert RecordParameters to RecordingParams
        val recordingParams = RecordingParams(
            recordingAudioPausesLimit = recordParams.recordingAudioPausesLimit,
            recordingAudioSupport = recordParams.recordingAudioSupport,
            recordingAudioPeopleLimit = recordParams.recordingAudioPeopleLimit,
            recordingAudioParticipantsTimeLimit = recordParams.recordingAudioParticipantsTimeLimit,
            recordingVideoPausesLimit = recordParams.recordingVideoPausesLimit,
            recordingVideoSupport = recordParams.recordingVideoSupport,
            recordingVideoPeopleLimit = recordParams.recordingVideoPeopleLimit,
            recordingVideoParticipantsTimeLimit = recordParams.recordingVideoParticipantsTimeLimit,
            recordingAllParticipantsSupport = recordParams.recordingAllParticipantsSupport,
            recordingVideoParticipantsSupport = recordParams.recordingVideoParticipantsSupport,
            recordingAllParticipantsFullRoomSupport = recordParams.recordingAllParticipantsFullRoomSupport,
            recordingVideoParticipantsFullRoomSupport = recordParams.recordingVideoParticipantsFullRoomSupport,
            recordingPreferredOrientation = recordParams.recordingPreferredOrientation,
            recordingSupportForOtherOrientation = recordParams.recordingSupportForOtherOrientation,
            recordingMultiFormatsSupport = recordParams.recordingMultiFormatsSupport,
            recordingHlsSupport = false,
            recordingAudioPausesCount = recordParams.recordingAudioPausesCount,
            recordingVideoPausesCount = recordParams.recordingVideoPausesCount
        )

        val options = RoomRecordParamsOptions(
            recordParams = recordingParams,
            parameters = parameters
        )

        roomRecordParams(options)
        propagateParameterChanges()
    }

    private suspend fun handleStartRecordsEvent(payload: Map<String, Any?>) {
        val socket = connectivity.socket ?: return

        val options = StartRecordsOptions(
            roomName = room.roomName,
            member = room.member,
            socket = socket.toSocketLike()
        )

        startRecords(options)
    }

    private suspend fun handleReInitiateRecordingEvent(payload: Map<String, Any?>) {
        val socket = connectivity.socket ?: return

        val options = ReInitiateRecordingOptions(
            roomName = room.roomName,
            member = room.member,
            socket = socket.toSocketLike(),
            adminRestrictSetting = room.adminRestrictSetting
        )

        reInitiateRecording(options)
    }

    private suspend fun handleRecordingNoticeEvent(payload: Map<String, Any?>) {
        val state = payload["state"] as? String ?: return
        val pauseCount = payload["pauseCount"] as? Int ?: 0
        val timeDone = payload["timeDone"] as? Int ?: 0

        val userRecordingParams = if (payload.containsKey("userRecordingParam") && 
            payload["userRecordingParam"] != null) {
            (payload["userRecordingParam"] as? Map<String, Any?>)?.let { map ->
                UserRecordingParams.fromMap(map)
            }
        } else {
            parameters.userRecordingParams
        }

        val options = RecordingNoticeOptions(
            state = state,
            userRecordingParams = userRecordingParams,
            pauseCount = pauseCount,
            timeDone = timeDone,
            parameters = parameters
        )

        recordingNotice(options)
        propagateParameterChanges()
    }

    private suspend fun handleTimeLeftRecordingEvent(payload: Map<String, Any?>) {
        val timeLeft = payload["timeLeft"] as? Int ?: return

        val options = TimeLeftRecordingOptions(
            timeLeft = timeLeft,
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            }
        )

        timeLeftRecording(options)
    }

    private suspend fun handleStoppedRecordingEvent(payload: Map<String, Any?>) {
        val state = payload["state"] as? String ?: return
        val reason = payload["reason"] as? String ?: ""

        val options = StoppedRecordingOptions(
            state = state,
            reason = reason,
            showAlert = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            }
        )

        stoppedRecording(options)
        propagateParameterChanges()
    }

    // Helper to convert SocketManager to SocketLike
    private fun SocketManager.toSocketLike(): SocketLike = object : SocketLike {
        override val isConnected: Boolean get() = this@toSocketLike.isConnected()
        override val id: String? get() = this@toSocketLike.id
        
        override fun emit(event: String, data: Map<String, Any?>) {
            runBlocking { this@toSocketLike.emit(event, data) }
        }
        
        override fun emitWithAck(event: String, data: Map<String, Any?>, ack: (Map<String, Any?>) -> Unit) {
            this@toSocketLike.emitWithAck(event, data) { response ->
                @Suppress("UNCHECKED_CAST")
                val mapped = (response as? Map<*, *>)?.let { it as Map<String, Any?> } ?: emptyMap()
                ack(mapped)
            }
        }
    }

    private inline fun <reified T> Any?.decodePayload(): T? {
        return when (this) {
            is T -> this
            is Map<*, *> -> runCatching {
                val element = this.toJsonElement()
                mediaSfuJson.decodeFromJsonElement<T>(element)
            }.onFailure { error ->
                println("MediaSFU - decodePayload: Failed to decode ${T::class.simpleName}")
                println("MediaSFU - decodePayload: Error: ${error.message}")
                error.printStackTrace()
            }.getOrNull()
            is String -> runCatching { 
                mediaSfuJson.decodeFromString<T>(this) 
            }.onFailure { error ->
                println("MediaSFU - decodePayload: Failed to decode string to ${T::class.simpleName}")
                println("MediaSFU - decodePayload: Error: ${error.message}")
            }.getOrNull()
            is JsonElement -> runCatching { 
                mediaSfuJson.decodeFromJsonElement<T>(this) 
            }.onFailure { error ->
                println("MediaSFU - decodePayload: Failed to decode JsonElement to ${T::class.simpleName}")
                println("MediaSFU - decodePayload: Error: ${error.message}")
            }.getOrNull()
            else -> {
                println("MediaSFU - decodePayload: Unsupported payload type: ${this?.let { it::class.simpleName }}")
                null
            }
        }
    }

    private fun Map<*, *>.toJsonElement(): JsonObject = buildJsonObject {
        for ((key, value) in this@toJsonElement) {
            val name = key as? String ?: continue
            put(name, value.toJsonElement())
        }
    }

    private fun Any?.toJsonElement(): JsonElement = when (this) {
        null -> JsonNull
        is JsonElement -> this
        is Map<*, *> -> this.toJsonElement()
        is Iterable<*> -> buildJsonArray {
            for (item in this@toJsonElement) {
                add(item.toJsonElement())
            }
        }
        is Array<*> -> buildJsonArray {
            for (item in this@toJsonElement) {
                add(item.toJsonElement())
            }
        }
        is Number -> JsonPrimitive(this)
        is Boolean -> JsonPrimitive(this)
        is String -> runCatching { mediaSfuJson.parseToJsonElement(this) }
            .getOrElse { JsonPrimitive(this) }
        else -> {
            // Handle org.json.JSONArray and org.json.JSONObject by converting to string and parsing
            val className = this::class.simpleName ?: ""
            if (className.contains("JSONArray") || className.contains("JSONObject")) {
                runCatching { mediaSfuJson.parseToJsonElement(this.toString()) }
                    .getOrElse { JsonPrimitive(toString()) }
            } else {
                JsonPrimitive(toString())
            }
        }
    }

    private fun applyInitialOptions() {
        options.credentials?.let { creds ->
            room.updateApiUserName(creds.apiUserName)
            room.updateApiKey(creds.apiKey)
        }
        room.updateLink(options.localLink)
        options.sourceParameters?.let { source ->
            connectivity.updateSocket(source.socket)
            connectivity.updateLocalSocket(source.localSocket)
            connectivity.updateDevice(source.device)
            connectivity.updateRoomResponse(source.roomData)
        }
        room.refreshFromParameters()
        display.refreshFromParameters()
        streams.refreshFromParameters()
        recording.refreshFromParameters()
        polls.refreshFromParameters()
        requests.refreshFromParameters()
        applySeedDataIfNeeded()
    }

    private fun applySeedDataIfNeeded() {
        if (seedApplied) return

        val hasParticipants = parameters.participants.isNotEmpty()
        val hasStreams = parameters.currentStreams.isNotEmpty()
        val explicitSeedRequest = options.useSeed == true
        val implicitSeedRequest = options.seedData != null && options.useSeed != false

        if (!explicitSeedRequest && !implicitSeedRequest) return
        if (!explicitSeedRequest && (hasParticipants || hasStreams)) return

        val seed = options.seedData ?: defaultSeedData()
        applySeedData(seed)
    }

    private fun applySeedData(seed: ModelSeedData) {
        seedApplied = true

        val fallback = defaultSeedData()
        val participants = seed.participants.ifEmpty { fallback.participants }
        val memberName = seed.member?.takeIf { it.isNotBlank() }
            ?: participants.firstOrNull()?.name
            ?: "Guest"
        val hostName = seed.host?.takeIf { it.isNotBlank() }
            ?: participants.firstOrNull { it.isHost }?.name
            ?: memberName
        val resolvedEventType = seed.eventType ?: fallback.eventType ?: EventType.CONFERENCE

        if (room.roomName.isBlank()) {
            room.updateRoomName("MediaSFU Demo")
        }
        room.updateMember(memberName)
        val resolvedLevel = participants.firstOrNull { it.name.equals(memberName, ignoreCase = true) }?.islevel
            ?.takeIf { it.isNotBlank() }
            ?: if (hostName.equals(memberName, ignoreCase = true)) "2" else "1"
        room.updateIslevel(resolvedLevel)

        parameters.youAreHost = hostName.equals(memberName, ignoreCase = true)
        parameters.youAreCoHost = false
        parameters.eventType = resolvedEventType
        parameters.meetingDisplayType = if (resolvedEventType == EventType.CHAT || resolvedEventType == EventType.BROADCAST) "all" else "media"

        room.updateParticipants(participants)

        val streamsSnapshot = buildSeedStreams(participants)
        val mutedStreams = streamsSnapshot.filter { it.muted == true }
        val breakoutRooms: List<List<ModelBreakoutParticipant>> = seed.breakoutRooms.map { roomParticipants ->
            roomParticipants.map { participant ->
                ModelBreakoutParticipant(name = participant.name, breakRoom = participant.breakRoom)
            }
        }

        parameters.streamNames = streamsSnapshot
        parameters.currentStreams = streamsSnapshot
    parameters.paginatedStreams = if (streamsSnapshot.isEmpty()) emptyList() else listOf(streamsSnapshot)
        parameters.nonAlVideoStreams = streamsSnapshot
        parameters.mixedAlVideoStreams = emptyList()
        parameters.nonAlVideoStreamsMuted = mutedStreams
        parameters.allAudioStreams = streamsSnapshot
        parameters.remoteScreenStreamState = emptyList()
        parameters.lStreams = streamsSnapshot
        parameters.lStreams_ = streamsSnapshot
        parameters.chatRefStreams = emptyList()
        parameters.mainScreenPerson = streamsSnapshot.firstOrNull()?.producerId ?: ""
        parameters.adminOnMainScreen = hostName.equals(streamsSnapshot.firstOrNull()?.name ?: "", ignoreCase = true)
        parameters.mainScreenFilled = streamsSnapshot.isNotEmpty()
        parameters.gotAllVids = streamsSnapshot.isNotEmpty()

        val activeNames = participants.map(Participant::name)
        parameters.activeNames = activeNames
        parameters.prevActiveNames = activeNames
        parameters.pActiveNames = activeNames
        parameters.dispActiveNames = activeNames
        parameters.pDispActiveNames = activeNames

        parameters.messages = seed.messages
        parameters.showMessagesBadge = seed.messages.isNotEmpty()

        messaging.messages.apply {
            clear()
            addAll(seed.messages)
        }
        messaging.showMessagesBadge = seed.messages.isNotEmpty()
        messaging.directMessageDetails = null

    waitingRoom.updateList(seed.waitingList)
    requests.updateList(seed.requests)
    requests.updateTotalPending(seed.requests.size + seed.waitingList.size)
        polls.updatePolls(seed.polls)
        val activePoll = seed.polls.firstOrNull { it.status?.equals("live", ignoreCase = true) == true }
        if (activePoll != null) {
            polls.updatePoll(activePoll)
        } else {
            polls.clearActivePoll()
        }

        breakout.updateRooms(breakoutRooms)
        meeting.startTimer()

        propagateParameterChanges()
        updateValidated(true)
    }

    private fun attemptAutoJoin() {
        if (connectivity.socket == null) return
        val roomName = room.roomName.takeUnless(String::isBlank) ?: return
        val adminPasscode = room.adminPasscode.takeUnless(String::isBlank) ?: return
        val apiUserName = resolveApiUserName().takeUnless(String::isBlank) ?: return
        val member = room.member.ifBlank { apiUserName }
        if (autoJoinJob?.isActive == true) return

        autoJoinJob = scope.launch {
            connectAndValidate(
                roomName = roomName,
                member = member,
                adminPasscode = adminPasscode,
                islevel = room.islevel.ifBlank { "0" },
                apiUserName = apiUserName,
                apiToken = room.apiToken
            ) {
                autoJoinJob = null
            }
        }
    }

    private fun resolveApiUserName(): String {
        return room.apiUserName.ifBlank {
            options.credentials?.apiUserName?.takeIf { it.isNotBlank() }
                ?: parameters.apiUserName
        }
    }

    fun updateValidated(newValue: Boolean) {
        if (_validated.value == newValue) return
        _validated.value = newValue
        parameters.validated = newValue
        if (!newValue) {
            initialMediaHydrated = false
        } else if (parameters.participants.isNotEmpty() && !initialMediaHydrated) {
            scope.launch {
                initializeMediaStateAfterValidation(
                    defaultMemberName = room.member.ifBlank { resolveApiUserName() }
                )
            }
        }
        notifyParametersChanged()
    }

    fun showAlert(message: String, type: String = "info", duration: Int = 3000) {
        alert.show(message, type, duration)
        parameters.showAlert(message, type, duration)
        notifyParametersChanged()
    }

    fun hideAlert() {
        alert.hide()
        parameters.hideAlert()
        notifyParametersChanged()
    }

    fun updatePolls(newPolls: List<Poll>) {
        polls.updatePolls(newPolls)
    }

    fun updatePoll(poll: Poll) {
        polls.updatePoll(poll)
    }

    fun clearActivePoll() {
        polls.clearActivePoll()
    }

    fun setPollModalVisible(visible: Boolean) {
        polls.setPollModalVisibility(visible)
    }

    fun showLoader() {
        if (_isLoading.value) return
        _isLoading.value = true
        parameters.isLoadingModalVisible = true
        notifyParametersChanged()
    }

    fun hideLoader() {
        if (!_isLoading.value) return
        _isLoading.value = false
        parameters.isLoadingModalVisible = false
        notifyParametersChanged()
    }

    fun openShareEvent() {
        modals.showShareEvent()
    }

    fun closeShareEvent() {
        modals.setShareEventVisibility(false)
    }

    fun openConfirmExit() {
        modals.showConfirmExit()
    }

    fun closeAllModals() {
        modals.closeAll()
    }

    fun openParticipants() {
        println("MediaSFU - openParticipants: Opening participants modal")
        println("MediaSFU - openParticipants: Current participants count = ${room.participants.size}")
        room.participants.forEachIndexed { index, participant ->
            println("MediaSFU - openParticipants: Participant $index: ${participant.name} (id=${participant.id})")
        }
        modals.showParticipants()
    }

    fun muteParticipant(participant: Participant) {
        val socket = connectivity.socket
        if (socket == null) {
            showAlert("Unable to mute participant. Connection not established.", "danger")
            return
        }

        val roomName = room.roomName.ifBlank { parameters.roomName }
        if (roomName.isBlank()) {
            showAlert("Missing room information. Please try again.", "danger")
            return
        }

        // Check if already muted or is host
        if (participant.muted == true) {
            return
        }
        if (participant.islevel == "2") {
            showAlert("Cannot mute the host.", "danger")
            return
        }

        scope.launch {
            runCatching {
                socket.emit("controlMedia", mapOf(
                    "participantId" to participant.id,
                    "participantName" to participant.name,
                    "type" to "all",
                    "roomName" to roomName
                ))
            }.onFailure { error ->
                println("MediaSFU - muteParticipant failed: ${error.message}")
                showAlert("Unable to mute ${participant.name}. Please try again.", "danger")
            }
        }
    }

    fun removeParticipant(participant: Participant) {
        val socket = connectivity.socket
        if (socket == null) {
            showAlert("Unable to remove participant. Connection not established.", "danger")
            return
        }

        val roomName = room.roomName.ifBlank { parameters.roomName }
        if (roomName.isBlank()) {
            showAlert("Missing room information. Please try again.", "danger")
            return
        }

        val currentMember = room.member.ifBlank { parameters.member }
        scope.launch {
            val alertBridge = ShowAlert { message, type, duration ->
                showAlert(message, type, duration)
            }

            val options = RemoveParticipantsOptions(
                coHostResponsibility = room.coHostResponsibility,
                participant = participant,
                member = currentMember,
                islevel = room.islevel.ifBlank { parameters.islevel.ifBlank { "0" } },
                showAlert = alertBridge,
                coHost = room.coHost,
                participants = room.participants.toList(),
                socket = socket,
                roomName = roomName,
                updateParticipants = { updated ->
                    room.updateParticipants(updated)
                }
            )

            runCatching {
                removeParticipants(options)
            }.onFailure { error ->
                println("MediaSFU - removeParticipant failed: ${error.message}")
                showAlert("Unable to remove ${participant.name}. Please try again.", "danger")
            }
        }
    }

    fun openMessages() {
        modals.showMessages()
        messaging.clearBadge()
    }

    fun openSettings() {
        modals.showSettings()
    }

    fun toggleMenu() {
        launchMenuModal(
            LaunchMenuModalOptions(
                updateIsMenuModalVisible = modals::setMenuVisibility,
                isMenuModalVisible = modals.isMenuVisible
            )
        )
    }

    fun togglePollModal(openExplicit: Boolean = false) {
        if (openExplicit) {
            setPollModalVisible(true)
            return
        }
        launchPoll(
            LaunchPollOptions(
                updateIsPollModalVisible = ::setPollModalVisible,
                isPollModalVisible = polls.isPollModalVisible
            )
        )
    }

    fun toggleRequestsModal() {
        launchRequests(
            LaunchRequestsOptions(
                updateIsRequestsModalVisible = { visible ->
                    if (visible) {
                        modals.showRequests()
                    } else {
                        modals.setRequestsVisibility(false)
                    }
                },
                isRequestsModalVisible = modals.isRequestsVisible
            )
        )
    }

    fun toggleWaitingModal() {
        launchWaiting(
            LaunchWaitingOptions(
                updateIsWaitingModalVisible = { visible ->
                    if (visible) {
                        modals.showWaiting()
                    } else {
                        modals.setWaitingVisibility(false)
                    }
                },
                isWaitingModalVisible = modals.isWaitingVisible
            )
        )
    }

    fun openRequests() {
        modals.showRequests()
    }

    fun closeRequests() {
        modals.setRequestsVisibility(false)
    }

    fun openWaitingRoom() {
        modals.showWaiting()
    }

    fun closeWaitingRoom() {
        modals.setWaitingVisibility(false)
    }

    fun closeConfirmExit() {
        modals.setConfirmExitVisibility(false)
    }

    fun closeConfirmHere() {
        modals.setConfirmHereVisibility(false)
    }

    fun confirmExitFromPrompt() {
        val isHost = room.youAreHost || room.islevel.equals("2", ignoreCase = true)
        closeConfirmExit()
        val successMessage = if (isHost) {
            "You ended the event for everyone."
        } else {
            "You have left the event."
        }
        exitSession(successMessage = successMessage)
    }

    fun acknowledgePresence() {
        closeConfirmHere()
    }

    fun handlePresenceTimeout() {
        closeConfirmHere()
        exitSession(successMessage = "You have been disconnected due to inactivity.")
    }

    fun exitSession(ban: Boolean = false, successMessage: String? = null) {
        closeAllModals()
        val roomName = room.roomName.ifBlank { parameters.roomName }
        val memberName = room.member.ifBlank { parameters.member }
        if (roomName.isBlank() || memberName.isBlank()) {
            showAlert("Join a room before exiting.", "warning")
            return
        }

        scope.launch {
            try {
                confirmExit(
                    ConfirmExitOptions(
                        socket = connectivity.socket,
                        localSocket = connectivity.localSocket,
                        member = memberName,
                        roomName = roomName,
                        ban = ban
                    )
                )
                successMessage?.let { message ->
                    showAlert(message, "info")
                }
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to exit the event.", "danger")
                return@launch
            }
            meeting.stopTimer(reset = true)
            updateValidated(false)
        }
    }

    fun createPoll(
        question: String,
        options: List<String>,
        type: String = "singleChoice",
        onComplete: (() -> Unit)? = null
    ) {
        val trimmedQuestion = question.trim()
        val trimmedOptions = options.map(String::trim).filter { it.isNotEmpty() }
        if (trimmedQuestion.isEmpty() || trimmedOptions.size < 2) {
            showAlert("Enter a question and at least two options", "warning")
            onComplete?.invoke()
            return
        }
        val roomName = room.roomName.ifBlank { parameters.roomName }
        if (roomName.isBlank()) {
            showAlert("Join a room before creating polls", "warning")
            onComplete?.invoke()
            return
        }
        val poll = Poll(
            question = trimmedQuestion,
            type = type,
            options = trimmedOptions,
            votes = List(trimmedOptions.size) { 0 }
        )
        scope.launch {
            try {
                handleCreatePoll(
                    HandleCreatePollOptions(
                        poll = poll,
                        socket = connectivity.socket,
                        roomName = roomName,
                        showAlert = ShowAlert { message, type, duration ->
                            showAlert(message, type, duration)
                        },
                        updateIsPollModalVisible = ::setPollModalVisible
                    )
                )
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to create poll", "danger")
            } finally {
                onComplete?.invoke()
            }
        }
    }

    fun endPoll(pollId: String, onComplete: (() -> Unit)? = null) {
        if (pollId.isBlank()) {
            onComplete?.invoke()
            return
        }
        val roomName = room.roomName.ifBlank { parameters.roomName }
        if (roomName.isBlank()) {
            showAlert("Join a room before ending polls", "warning")
            onComplete?.invoke()
            return
        }
        scope.launch {
            try {
                handleEndPoll(
                    HandleEndPollOptions(
                        pollId = pollId,
                        socket = connectivity.socket,
                        showAlert = ShowAlert { message, type, duration ->
                            showAlert(message, type, duration)
                        },
                        roomName = roomName,
                        updateIsPollModalVisible = ::setPollModalVisible
                    )
                )
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to end poll", "danger")
            } finally {
                onComplete?.invoke()
            }
        }
    }

    fun voteInPoll(
        pollId: String,
        optionIndex: Int,
        onComplete: (() -> Unit)? = null
    ) {
        if (pollId.isBlank()) {
            onComplete?.invoke()
            return
        }
        val memberName = room.member.ifBlank { parameters.member }
        val roomName = room.roomName.ifBlank { parameters.roomName }
        if (memberName.isBlank() || roomName.isBlank()) {
            showAlert("Join a room before voting", "warning")
            onComplete?.invoke()
            return
        }
        scope.launch {
            try {
                handleVotePoll(
                    HandleVotePollOptions(
                        pollId = pollId,
                        optionIndex = optionIndex,
                        socket = connectivity.socket,
                        showAlert = ShowAlert { message, type, duration ->
                            showAlert(message, type, duration)
                        },
                        member = memberName,
                        roomName = roomName,
                        updateIsPollModalVisible = ::setPollModalVisible
                    )
                )
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to submit vote", "danger")
            } finally {
                onComplete?.invoke()
            }
        }
    }

    fun toggleAudio() {
        scope.launch {
            try {
                val options = ClickAudioOptions(parameters = createClickAudioParameters())
                clickAudio(options)
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to toggle audio.", "danger")
            }
        }
    }

    fun toggleVideo() {
        scope.launch {
            try {
                val options = ClickVideoOptions(parameters = createClickVideoParameters())
                clickVideo(options)
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to toggle video.", "danger")
            }
        }
    }

    fun toggleScreenShare() {
        scope.launch {
            try {
                val options = ClickScreenShareOptions(parameters = createClickScreenShareParameters())
                clickScreenShare(options)
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to toggle screen share.", "danger")
            }
        }
    }

    private fun updateRequestsList(newList: List<Request>) {
        requests.updateList(newList)
        requests.updateTotalPending(newList.size + waitingRoom.waitingRoomList.size)
    }

    private fun updateWaitingList(newList: List<WaitingRoomParticipant>) {
        waitingRoom.updateList(newList)
        requests.updateTotalPending(newList.size + requests.requests.size)
    }

    fun handleRequestAction(request: Request, action: String) {
        val roomName = room.roomName.ifBlank { parameters.roomName }
        if (roomName.isBlank()) {
            showAlert("Join a room before responding to requests.", "warning")
            return
        }

        val currentRequests = requests.requests.toList()
        scope.launch {
            try {
                respondToRequests(
                    RespondToRequestsOptions(
                        socket = connectivity.socket,
                        request = request,
                        updateRequestList = ::updateRequestsList,
                        requestList = currentRequests,
                        action = action,
                        roomName = roomName
                    )
                )
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to update request status.", "danger")
            }
        }
    }

    fun handleWaitingParticipant(participant: WaitingRoomParticipant, allow: Boolean) {
        val roomName = room.roomName.ifBlank { parameters.roomName }
        if (roomName.isBlank()) {
            showAlert("Join a room before managing the waiting room.", "warning")
            return
        }

        val currentWaiting = waitingRoom.waitingRoomList.toList()
        scope.launch {
            try {
                respondToWaiting(
                    RespondToWaitingOptions(
                        participantId = participant.id,
                        participantName = participant.name,
                        updateWaitingList = ::updateWaitingList,
                        waitingList = currentWaiting,
                        type = allow,
                        roomName = roomName,
                        socket = connectivity.socket
                    )
                )
            } catch (error: Throwable) {
                showAlert(error.message ?: "Unable to update waiting room.", "danger")
            }
        }
    }

    internal fun createRequestsModalProps(): RequestsModalProps {
        return RequestsModalProps(
            isVisible = modals.isRequestsVisible,
            requests = requests.filteredRequests.toList(),
            filter = requests.filter,
            pendingCount = requests.counter,
            onFilterChange = ::onRequestFilterChange,
            onClose = ::closeRequests,
            onAccept = { request -> handleRequestAction(request, "accepted") },
            onReject = { request -> handleRequestAction(request, "rejected") }
        )
    }

    internal fun createWaitingModalProps(): WaitingModalProps {
        return WaitingModalProps(
            isVisible = modals.isWaitingVisible,
            participants = waitingRoom.filteredWaitingRoomList.toList(),
            filter = waitingRoom.filter,
            pendingCount = waitingRoom.counter,
            onFilterChange = ::onWaitingRoomFilterChange,
            onClose = ::closeWaitingRoom,
            onAllow = { participant -> handleWaitingParticipant(participant, true) },
            onDeny = { participant -> handleWaitingParticipant(participant, false) }
        )
    }

    internal fun createMenuModalProps(): MenuModalProps {
        return MenuModalProps(
            state = this,
            isVisible = modals.isMenuVisible,
            roomName = room.roomName,
            roomLink = room.link,
            adminPasscode = room.adminPasscode,
            totalRequests = requests.totalPending,
            waitingCount = waitingRoom.counter,
            islevel = room.islevel,
            coHost = room.coHost,
            member = room.member,
            eventType = room.eventType,
            coHostResponsibility = room.coHostResponsibility,
            onClose = { modals.setMenuVisibility(false) },
            onOpenRequests = {
                modals.setMenuVisibility(false)
                openRequests()
            },
            onOpenWaiting = {
                modals.setMenuVisibility(false)
                openWaitingRoom()
            },
            onOpenPolls = {
                modals.setMenuVisibility(false)
                togglePollModal(openExplicit = true)
            },
            onOpenShareEvent = {
                modals.setMenuVisibility(false)
                openShareEvent()
            },
            onOpenSettings = {
                modals.showSettings()
            },
            onOpenRecording = {
                modals.showRecording()
            },
            onOpenCoHost = {
                modals.showCoHost()
            },
            onOpenMediaSettings = {
                modals.showMediaSettings()
            },
            onOpenDisplaySettings = {
                modals.showDisplaySettings()
            },
            onOpenBreakoutRooms = {
                modals.toggleBreakoutRooms()
            }
        )
    }

    internal fun createParticipantsModalProps(): ParticipantsModalProps {
        return ParticipantsModalProps(
            state = this,
            isVisible = modals.isParticipantsVisible,
            filter = room.participantsFilter,
            participants = room.participants.toList(),
            filteredParticipants = room.filteredParticipants.toList(),
            participantCount = room.participantsCounter,
            onFilterChange = ::onParticipantsFilterChange,
            onClose = ::closeAllModals
        )
    }

    internal fun createMessagesModalProps(): MessagesModalProps {
        return MessagesModalProps(
            state = this,
            isVisible = modals.isMessagesVisible,
            messages = messaging.messages.toList(),
            onClose = ::closeAllModals,
            // Message system fields
            eventType = room.eventType,
            member = room.member,
            islevel = room.islevel,
            coHost = room.coHost,
            coHostResponsibility = room.coHostResponsibility,
            startDirectMessage = messaging.startDirectMessage,
            directMessageDetails = messaging.directMessageDetails,
            chatSetting = media.chatSetting,
            roomName = room.roomName,
            socket = connectivity.socket,
            showAlert = ::showAlert,
            onSendMessage = { options ->
                scope.launch {
                    sendMessage(options)
                }
            }
        )
    }

    internal fun createShareEventModalProps(): ShareEventModalProps {
        val resolvedRoomName = room.roomName.ifBlank { parameters.roomName }
        val resolvedPasscode = room.adminPasscode.ifBlank { parameters.adminPasscode }
        val isHost = room.youAreHost || room.islevel.equals("2", ignoreCase = true)
        val visiblePasscode = resolvedPasscode.takeIf { isHost && it.isNotBlank() }
        val shareLink = effectiveLocalLink().ifBlank { parameters.link }

        return ShareEventModalProps(
            state = this,
            isVisible = modals.isShareEventVisible,
            roomName = resolvedRoomName,
            shareLink = shareLink,
            adminPasscode = visiblePasscode,
            isHost = isHost,
            eventType = room.eventType,
            shareButtonsEnabled = shareLink.isNotBlank(),
            onDismiss = ::closeShareEvent
        )
    }

    internal fun createConfirmExitModalProps(): ConfirmExitModalProps {
        val isHost = room.youAreHost || room.islevel.equals("2", ignoreCase = true)
        val memberName = room.member.ifBlank { parameters.member }
        val roomName = room.roomName.ifBlank { parameters.roomName }
        val message = if (isHost) {
            "This will end the event for everyone. Are you sure you want to continue?"
        } else {
            "Are you sure you want to exit the event?"
        }
        val confirmLabel = if (isHost) "End Event" else "Exit"

        return ConfirmExitModalProps(
            state = this,
            isVisible = modals.isConfirmExitVisible,
            memberName = memberName,
            roomName = roomName,
            isHost = isHost,
            message = message,
            confirmLabel = confirmLabel,
            onConfirm = ::confirmExitFromPrompt,
            onDismiss = ::closeConfirmExit
        )
    }

    internal fun createConfirmHereModalProps(): ConfirmHereModalProps {
        return ConfirmHereModalProps(
            state = this,
            isVisible = modals.isConfirmHereVisible,
            message = "Are you still there?",
            countdownSeconds = CONFIRM_HERE_COUNTDOWN_SECONDS,
            onConfirm = ::acknowledgePresence,
            onTimeout = ::handlePresenceTimeout,
            onDismiss = ::closeConfirmHere
        )
    }

    internal fun createLoadingModalProps(): com.mediasfu.sdk.ui.components.display.LoadingModalOptions {
        return com.mediasfu.sdk.ui.components.display.LoadingModalOptions(
            isVisible = modals.isLoadingVisible,
            backgroundColor = 0x80000000.toInt(),
            indicatorColor = 0xFFFFFFFF.toInt(),
            displayColor = 0xFFFFFFFF.toInt()
        )
    }

    internal fun createRecordingModalParameters(): com.mediasfu.sdk.ui.components.recording.RecordingModalParameters {
        return com.mediasfu.sdk.ui.components.recording.RecordingModalParameters(
            recordPaused = recording.recordPaused,
            recordingVideoType = recording.recordingVideoType,
            recordingDisplayType = recording.recordingDisplayType,
            recordingBackgroundColor = recording.recordingBackgroundColor,
            recordingNameTagsColor = recording.recordingNameTagsColor,
            recordingOrientationVideo = recording.recordingOrientationVideo,
            recordingNameTags = recording.recordingNameTags,
            recordingAddText = recording.recordingAddText,
            recordingCustomText = recording.recordingCustomText,
            recordingCustomTextPosition = recording.recordingCustomTextPosition,
            recordingCustomTextColor = recording.recordingCustomTextColor,
            recordingMediaOptions = recording.recordingMediaOptions,
            recordingAudioOptions = recording.recordingAudioOptions,
            recordingVideoOptions = recording.recordingVideoOptions,
            recordingAddHLS = recording.recordingAddHLS,
            eventType = parameters.eventType,
            updateRecordingVideoType = recording::updateRecordingVideoType,
            updateRecordingDisplayType = recording::updateRecordingDisplayType,
            updateRecordingBackgroundColor = recording::updateRecordingBackgroundColor,
            updateRecordingNameTagsColor = recording::updateRecordingNameTagsColor,
            updateRecordingOrientationVideo = recording::updateRecordingOrientationVideo,
            updateRecordingNameTags = recording::updateRecordingNameTags,
            updateRecordingAddText = recording::updateRecordingAddText,
            updateRecordingCustomText = recording::updateRecordingCustomText,
            updateRecordingCustomTextPosition = recording::updateRecordingCustomTextPosition,
            updateRecordingCustomTextColor = recording::updateRecordingCustomTextColor,
            updateRecordingMediaOptions = recording::updateRecordingMediaOptions,
            updateRecordingAudioOptions = recording::updateRecordingAudioOptions,
            updateRecordingVideoOptions = recording::updateRecordingVideoOptions,
            updateRecordingAddHLS = recording::updateRecordingAddHLS
        )
    }

    internal fun createRecordingModalProps(): com.mediasfu.sdk.ui.components.recording.RecordingModalOptions {
        return com.mediasfu.sdk.ui.components.recording.RecordingModalOptions(
            isRecordingModalVisible = modals.isRecordingVisible,
            onClose = { toggleRecording() },
            confirmRecording = { _ ->
                coroutineScope.launch {
                    runCatching {
                        confirmRecording(
                            MethodConfirmRecordingOptions(
                                parameters = createConfirmRecordingParameters()
                            )
                        )
                    }.onFailure { error ->
                        showAlert(
                            error.message ?: "Unable to confirm recording.",
                            "danger"
                        )
                    }
                }
            },
            startRecording = { _ ->
                coroutineScope.launch {
                    runCatching {
                        startRecording(
                            MethodStartRecordingOptions(
                                parameters = createStartRecordingParameters()
                            )
                        )
                    }.onFailure { error ->
                        showAlert(
                            error.message ?: "Unable to start recording.",
                            "danger"
                        )
                    }
                }
            },
            parameters = createRecordingModalParameters()
        )
    }

    private fun ModelMediaDeviceInfo.toUiDevice(): UiMediaDeviceInfo {
        return UiMediaDeviceInfo(
            deviceId = deviceId,
            label = label,
            kind = kind.toString()
        )
    }

    internal fun createMediaSettingsModalParameters(): MediaSettingsModalParameters {
        return object : MediaSettingsModalParameters {
            override val userDefaultVideoInputDevice: String
                get() = parameters.userDefaultVideoInputDevice
            override val userDefaultAudioInputDevice: String
                get() = parameters.userDefaultAudioInputDevice
            override val videoInputs: List<UiMediaDeviceInfo>
                get() = parameters.videoInputs.map { it.toUiDevice() }
            override val audioInputs: List<UiMediaDeviceInfo>
                get() = parameters.audioInputs.map { it.toUiDevice() }
            override val isMediaSettingsModalVisible: Boolean
                get() = modals.isMediaSettingsVisible
            
            override fun updateIsMediaSettingsModalVisible(value: Boolean) {
                modals.updateIsMediaSettingsVisible(value)
            }
            
            override fun getUpdatedAllParams(): MediaSettingsModalParameters {
                return this
            }
        }
    }

    internal fun createMediaSettingsModalProps(): MediaSettingsModalOptions {
        return MediaSettingsModalOptions(
            isVisible = modals.isMediaSettingsVisible,
            onClose = { toggleMediaSettings() },
            switchCameraOnPress = { _: UiSwitchVideoAltOptions ->
                coroutineScope.launch {
                    switchVideoAlt(
                        com.mediasfu.sdk.methods.stream_methods.SwitchVideoAltOptions(
                            parameters = createSwitchVideoAltParameters()
                        )
                    )
                }
            },
            switchVideoOnPress = { uiOptions: UiSwitchVideoOptions ->
                coroutineScope.launch {
                    switchVideo(
                        com.mediasfu.sdk.methods.stream_methods.SwitchVideoOptions(
                            videoPreference = uiOptions.videoPreference,
                            parameters = createSwitchVideoParameters()
                        )
                    )
                }
            },
            switchAudioOnPress = { uiOptions: UiSwitchAudioOptions ->
                coroutineScope.launch {
                    switchAudio(
                        com.mediasfu.sdk.methods.stream_methods.SwitchAudioOptions(
                            audioPreference = uiOptions.audioPreference,
                            parameters = createSwitchAudioParameters()
                        )
                    )
                }
            },
            parameters = createMediaSettingsModalParameters()
        )
    }

    internal fun createDisplaySettingsModalParameters(): DisplaySettingsModalParameters {
        return object : DisplaySettingsModalParameters {
            override val meetingDisplayType: String
                get() = display.meetingDisplayType
            override val autoWave: Boolean
                get() = display.autoWave
            override val forceFullDisplay: Boolean
                get() = display.forceFullDisplay
            override val meetingVideoOptimized: Boolean
                get() = display.meetingVideoOptimized
            
            override fun updateMeetingDisplayType(value: String) {
                display.updateMeetingDisplayType(value)
            }
            
            override fun updateAutoWave(value: Boolean) {
                display.updateAutoWave(value)
            }
            
            override fun updateForceFullDisplay(value: Boolean) {
                display.updateForceFullDisplay(value)
            }
            
            override fun updateMeetingVideoOptimized(value: Boolean) {
                display.updateMeetingVideoOptimized(value)
            }
        }
    }

    internal fun createDisplaySettingsModalProps(): DisplaySettingsModalOptions {
        return DisplaySettingsModalOptions(
            isVisible = modals.isDisplaySettingsVisible,
            onClose = { toggleDisplaySettings() },
            onModifySettings = { _ ->
                modals.updateIsDisplaySettingsVisible(false)
            },
            parameters = createDisplaySettingsModalParameters()
        )
    }

    internal fun createCoHostModalProps(): CoHostModalOptions {
        val currentRoomName = room.roomName.ifBlank { parameters.roomName }
        val activeSocket = connectivity.socket
        return CoHostModalOptions(
            isCoHostModalVisible = modals.isCoHostVisible,
            onCoHostClose = { toggleCoHost() },
            onModifyCoHostSettings = { uiOptions ->
                println("MediaSFU - createCoHostModalProps: onModifyCoHostSettings called")
                println("MediaSFU - createCoHostModalProps: selectedParticipant='${uiOptions.selectedParticipant}', coHost='${uiOptions.coHost}'")
                
                // Call the actual modifyCoHostSettings function
                coroutineScope.launch {
                    println("MediaSFU - createCoHostModalProps: Launching modifyCoHostSettings coroutine")
                    
                    // Convert UI options to method options
                    val methodOptions = com.mediasfu.sdk.methods.co_host_methods.ModifyCoHostSettingsOptions(
                        roomName = uiOptions.roomName,
                        showAlert = uiOptions.showAlert,
                        selectedParticipant = uiOptions.selectedParticipant,
                        coHost = uiOptions.coHost,
                        coHostResponsibility = uiOptions.coHostResponsibility.toModelList(), // Convert UI to Model
                        updateIsCoHostModalVisible = uiOptions.updateIsCoHostModalVisible,
                        updateCoHostResponsibility = { modelList -> 
                            uiOptions.updateCoHostResponsibility(modelList.toUiList()) // Convert Model to UI
                        },
                        updateCoHost = uiOptions.updateCoHost,
                        socket = uiOptions.socket
                    )
                    
                    modifyCoHostSettings(methodOptions)
                    println("MediaSFU - createCoHostModalProps: modifyCoHostSettings completed")
                }
            },
            currentCohost = room.coHost,
            participants = room.filteredParticipants.toList(),
            coHostResponsibility = room.coHostResponsibility.toUiList(),
            roomName = currentRoomName,
            showAlert = parameters.showAlert,
            updateCoHostResponsibility = { responsibilities ->
                room.updateCoHostResponsibility(responsibilities.toModelList())
            },
            updateCoHost = room::updateCoHost,
            updateIsCoHostModalVisible = modals::updateIsCoHostVisible,
            socket = activeSocket
        )
    }
    
    internal fun createBreakoutRoomsModalParameters(): BreakoutRoomsModalParameters {
        return object : BreakoutRoomsModalParameters() {
            override val participants: List<Participant>
                get() = room.filteredParticipants.toList()
            override val showAlert: ShowAlert?
                get() = parameters.showAlert
            override val socket: SocketManager?
                get() = connectivity.socket
            override val localSocket: SocketManager?
                get() = connectivity.localSocket
            override val itemPageLimit: Int
                get() = parameters.itemPageLimit
            override val meetingDisplayType: String
                get() = display.meetingDisplayType
            override val prevMeetingDisplayType: String
                get() = display.prevMeetingDisplayType
            override val roomName: String
                get() = room.roomName.ifBlank { parameters.roomName }
            override val shareScreenStarted: Boolean
                get() = media.shareScreenStarted
            override val shared: Boolean
                get() = media.shared
            override val breakOutRoomStarted: Boolean
                get() = breakout.breakOutRoomStarted
            override val breakOutRoomEnded: Boolean
                get() = breakout.breakOutRoomEnded
            override val canStartBreakout: Boolean
                get() = breakout.canStartBreakout
            override val breakoutRooms: List<List<UiBreakoutParticipant>>
                get() = breakout.breakoutRooms.toUiRooms()
            
            override val updateBreakOutRoomStarted: (Boolean) -> Unit
                get() = breakout::updateBreakOutRoomStarted
            override val updateBreakOutRoomEnded: (Boolean) -> Unit
                get() = breakout::updateBreakOutRoomEnded
            override val updateCurrentRoomIndex: (Int) -> Unit
                get() = breakout::updateCurrentRoomIndex
            override val updateCanStartBreakout: (Boolean) -> Unit
                get() = breakout::updateCanStartBreakout
            override val updateBreakoutRooms: (List<List<UiBreakoutParticipant>>) -> Unit
                get() = { rooms -> breakout.updateBreakoutRooms(rooms.toModelRooms()) }
            override val updateMeetingDisplayType: (String) -> Unit
                get() = display::updateMeetingDisplayType
            
            override fun getUpdatedAllParams(): BreakoutRoomsModalParameters {
                return this
            }
        }
    }

    internal fun createBreakoutRoomsModalProps(): BreakoutRoomsModalOptions {
        return BreakoutRoomsModalOptions(
            isVisible = modals.isBreakoutRoomsVisible,
            onBreakoutRoomsClose = { toggleBreakoutRooms() },
            parameters = createBreakoutRoomsModalParameters()
        )
    }

    fun totalPages(): Int {
        val configured = if (display.numberPages >= 0) display.numberPages + 1 else 0
        val available = parameters.paginatedStreams.size
        val candidate = maxOf(configured, available)
        return if (candidate <= 0) 1 else candidate
    }

    fun hasPreviousPage(): Boolean = display.currentUserPage > 0

    fun hasNextPage(): Boolean = display.currentUserPage < totalPages() - 1

    fun onPageChange(targetPage: Int) {
        val total = totalPages()
        if (total <= 0) return
        val sanitized = targetPage.coerceIn(0, total - 1)
        if (sanitized == display.currentUserPage) return
        launchInScope {
            val available = parameters.paginatedStreams.size
            val targetIndex = if (available == 0) sanitized else sanitized.coerceAtMost(available - 1)
            if (available == 0) {
                display.updateCurrentUserPage(targetIndex)
                propagateParameterChanges()
            } else {
                try {
                    generatePageContent(
                        GeneratePageContentOptions(
                            page = targetIndex,
                            parameters = pageContentParameters
                        )
                    )
                    propagateParameterChanges()
                } catch (error: Throwable) {
                    showAlert(error.message ?: "Unable to change page.", "danger")
                }
            }
        }
    }

    internal fun launchInScope(block: suspend CoroutineScope.() -> Unit) {
        scope.launch(block = block)
    }

    fun toggleRecording() {
        val updateModalVisibility: (Boolean) -> Unit = { visible ->
            var changed = false
            if (modals.isRecordingVisible != visible) {
                modals.isRecordingVisible = visible
                changed = true
            }
            if (parameters.isRecordingModalVisible != visible) {
                parameters.updateIsRecordingModalVisible(visible)
                changed = true
            }
            if (changed) {
                notifyParametersChanged()
            }
        }

        val launchOptions = LaunchRecordingOptions(
            updateIsRecordingModalVisible = updateModalVisibility,
            isRecordingModalVisible = modals.isRecordingVisible,
            showAlert = ::showAlert,
            stopLaunchRecord = parameters.stopLaunchRecord,
            canLaunchRecord = parameters.canLaunchRecord,
            recordingAudioSupport = recording.recordingAudioSupport,
            recordingVideoSupport = recording.recordingVideoSupport,
            updateCanRecord = { value -> recording.updateCanRecord(value) },
            updateClearedToRecord = { value -> recording.updateClearedToRecord(value) },
            recordStarted = recording.recordStarted,
            recordPaused = recording.recordPaused,
            localUIMode = options.useLocalUIMode ?: parameters.localUIMode
        )

        launchRecording(launchOptions)
    }

    fun onParticipantsFilterChange(filter: String) {
        room.participantsFilter = filter
        if (filter.isBlank()) {
            room.updateFilteredParticipants(room.participants)
        } else {
            room.updateFilteredParticipants(
                room.participants.filter { participant ->
                    participant.name.contains(filter, ignoreCase = true)
                }
            )
        }
        notifyParametersChanged()
    }

    fun onWaitingRoomFilterChange(filter: String) {
        waitingRoom.filter = filter
        waitingRoom.updateFilteredList()
        notifyParametersChanged()
    }

    fun onRequestFilterChange(filter: String) {
        requests.filter = filter
        requests.updateFilteredList()
        notifyParametersChanged()
    }

    suspend fun joinRoom(
        socket: SocketManager?,
        roomName: String,
        islevel: String,
        member: String,
        sec: String,
        apiUserName: String
    ): ResponseJoinRoom {
        return try {
            // STEP 1: Join the room
            val options = JoinRoomClientOptions(
                socket = socket,
                roomName = roomName,
                islevel = islevel,
                member = member,
                sec = sec,
                apiUserName = apiUserName
            )
            val response = options.joinMediaSFURoom()
            
            // TODO: Temporarily commented out - needs proper implementation
            /*
            // STEP 2: Update room data with server response
            updateRoomData(response)
            
            // STEP 3: Update room parameters client (sync with server)
            if (socket != null && !isLocal) {
                try {
                    updateRoomParametersClient(
                        UpdateRoomParametersClientOptions(
                            parameters = parameters,
                            roomName = roomName,
                            member = member,
                            socket = socket
                        )
                    )
                } catch (e: Exception) {
                    println("MediaSFU - Warning: updateRoomParametersClient failed: ${e.message}")
                }
            }
            */
            
            // STEP 4: Setup socket listeners for real-time events
            if (socket != null) {
                try {
                    setupSocketListeners(socket)
                } catch (e: Exception) {
                    println("MediaSFU - Warning: setupSocketListeners failed: ${e.message}")
                }
            }
            
            response
        } catch (e: Exception) {
            // Error handling with user notification
            showAlert(
                message = "Failed to join room: ${e.message}",
                type = "danger"
            )
            throw e
        }
    }

    // Note: setupSocketListeners() is already fully implemented at line ~1122
    // with all 30+ event handlers. This duplicate stub has been removed.

    fun connectAndValidate(
        roomName: String,
        member: String,
        adminPasscode: String,
        islevel: String,
        apiUserName: String,
        apiToken: String,
        onComplete: (Boolean) -> Unit = {}
    ) {
        println("MediaSFU - connectAndValidate: ENTRY roomName=$roomName member=$member")
        val trimmedRoomName = roomName.trim()
        val trimmedMember = member.trim()
        val trimmedAdminPasscode = adminPasscode.trim()
        val trimmedIslevel = islevel.trim()
        val trimmedApiUserName = apiUserName.trim()
        val trimmedApiToken = apiToken.trim()

        if (trimmedRoomName.isBlank()) {
            showAlert("Please provide a room name.", "error")
            onComplete(false)
            return
        }

        showLoader()
        println("MediaSFU - connectAndValidate: launching coroutine")
        scope.launch {
            try {
                val resolvedApiUserName = trimmedApiUserName.ifBlank { resolveApiUserName() }
                if (resolvedApiUserName.isBlank()) {
                    showAlert("Please provide an API username.", "error")
                    onComplete(false)
                    return@launch
                }

                val resolvedMember = trimmedMember.ifBlank { resolvedApiUserName }
                val resolvedIslevel = trimmedIslevel.ifBlank { room.islevel.ifBlank { "0" } }
                val resolvedLink = effectiveLocalLink()
                val useLocalJoin = shouldUseLocalJoin(resolvedLink, trimmedAdminPasscode)

                room.updateRoomName(trimmedRoomName)
                room.updateMember(resolvedMember)
                room.updateAdminPasscode(trimmedAdminPasscode)
                room.updateIslevel(resolvedIslevel)
                room.updateApiUserName(resolvedApiUserName)
                room.updateApiToken(trimmedApiToken)
                if (resolvedLink.isNotBlank()) {
                    room.updateLink(resolvedLink)
                }

                val activeSocket = when {
                    useLocalJoin -> connectivity.localSocket ?: connectivity.socket
                    else -> connectivity.socket
                }

                if (activeSocket == null) {
                    showAlert("Socket connection is not established.", "danger")
                    onComplete(false)
                    return@launch
                }

                val response = if (useLocalJoin) {
                    val (joinResponse, localResponse) = performLocalJoin(
                        socket = activeSocket,
                        roomName = trimmedRoomName,
                        islevel = resolvedIslevel,
                        member = resolvedMember,
                        sec = trimmedAdminPasscode,
                        apiUserName = resolvedApiUserName
                    )
                    applyLocalJoinMetadata(localResponse, resolvedLink)
                    joinResponse
                } else {
                    joinRoom(
                        socket = activeSocket,
                        roomName = trimmedRoomName,
                        islevel = resolvedIslevel,
                        member = resolvedMember,
                        sec = trimmedAdminPasscode,
                        apiUserName = resolvedApiUserName
                    )
                }

                if (response.success != true) {
                    val reason = response.reason?.takeIf { it.isNotBlank() }
                        ?: when {
                            response.banned == true -> "You have been removed from this event."
                            response.suspended == true -> "This event is currently suspended."
                            response.noAdmin == true -> "Host has not joined yet."
                            else -> "Unable to join the event."
                        }
                    showAlert(reason, "danger")
                    onComplete(false)
                    return@launch
                }

                room.updateRoomData(response)
                connectivity.updateRoomResponse(response)
                updateRoomParametersClient(
                    UpdateRoomParametersClientOptions(
                        parameters = UpdateRoomParametersBridge()
                    )
                )
                println("MediaSFU - connectAndValidate: about to updateValidated(true)")
                updateValidated(true)
                println("MediaSFU - connectAndValidate: launching initializeMediaStateAfterValidation")
                // Initialize UI immediately like Flutter does - don't wait for allMembers
                // This will use hostLabel/resolvedMember as the initial participant
                scope.launch {
                    println("MediaSFU - connectAndValidate: inside init coroutine, calling initializeMediaStateAfterValidation")
                    initializeMediaStateAfterValidation(resolvedMember)
                }
                println("MediaSFU - connectAndValidate: starting timer")
                meeting.startTimer()
                showAlert("Connected to ${trimmedRoomName}", "success")
                onComplete(true)
            } catch (error: Throwable) {
                showAlert(error.message ?: "Failed to connect", "error")
                onComplete(false)
            } finally {
                hideLoader()
            }
        }
    }

    private fun effectiveLocalLink(): String = room.link.ifBlank { options.localLink }

    private fun shouldUseLocalJoin(link: String, adminPasscode: String): Boolean {
        if (link.isNotBlank()) return true
        if (connectivity.localSocket != null) return true
        return adminPasscode.length == 32 && adminPasscode.all { it.isLetterOrDigit() }
    }

    private suspend fun socketJoinLocalRoom(options: JoinLocalRoomOptions) = joinLocalRoom(options)

    private suspend fun performLocalJoin(
        socket: SocketManager,
        roomName: String,
        islevel: String,
        member: String,
        sec: String,
        apiUserName: String
    ): Pair<ResponseJoinRoom, ResponseJoinLocalRoom> {
        val options = JoinLocalRoomOptions(
            socket = socket,
            roomName = roomName,
            islevel = islevel,
            member = member,
            sec = sec,
            apiUserName = apiUserName
        )

        val localResponse = socketJoinLocalRoom(options).getOrElse { error ->
            throw error
        }

        val joinResponse = createResponseJoinRoom(
            CreateResponseJoinRoomOptions(localRoom = localResponse)
        )

        return joinResponse to localResponse
    }

    private fun applyLocalJoinMetadata(localResponse: ResponseJoinLocalRoom, fallbackLink: String) {
        val resolvedLink = localResponse.mediasfuURL?.takeIf { it.isNotBlank() } ?: fallbackLink
        if (resolvedLink.isNotBlank()) {
            room.updateLink(resolvedLink)
        }

        localResponse.apiUserName?.takeIf { it.isNotBlank() }?.let { value ->
            room.updateApiUserName(value)
        }

        localResponse.apiKey?.takeIf { it.isNotBlank() }?.let { value ->
            room.updateApiKey(value)
        }

        localResponse.allowRecord?.let { allowed ->
            recording.updateCanRecord(allowed)
            room.updateConfirmedToRecord(allowed)
        }
    }

    private suspend fun initializeMediaStateAfterValidation(defaultMemberName: String) {
        val participantsSnapshot = parameters.participants
        println(
            "MediaSFU - initializeMediaStateAfterValidation: invoked participants=${participantsSnapshot.size} " +
                "existingStreams=${parameters.allVideoStreamsState.size} defaultMember=$defaultMemberName"
        )

        // Even if participants are empty, we can still initialize with the member name
        // This matches Flutter's behavior of calling prepopulateUserMedia immediately
        // Priority: 1) defaultMemberName (the joining member), 2) mainScreenPerson, 3) hostLabel
        val targetName = listOfNotNull(
            defaultMemberName.takeIf { it.isNotBlank() },
            parameters.mainScreenPerson.takeIf { it.isNotBlank() },
            participantsSnapshot.firstOrNull { it.isHost }?.name?.takeIf { it.isNotBlank() },
            participantsSnapshot.firstOrNull()?.name?.takeIf { it.isNotBlank() },
            parameters.hostLabel.takeIf { it.isNotBlank() }
        ).firstOrNull()

        if (targetName.isNullOrBlank()) {
            println("MediaSFU - initializeMediaStateAfterValidation: no target name available")
            propagateParameterChanges()
            return
        }

        var effectiveParticipants = participantsSnapshot
        if (effectiveParticipants.isEmpty()) {
            val normalizedLevel = if (targetName.equals(parameters.member, ignoreCase = true)) {
                parameters.islevel.ifBlank { "1" }
            } else {
                "1"
            }

            val placeholderParticipant = Participant(
                id = "placeholder-${targetName.lowercase().replace(seedNameSanitizer, "-").trim('-').ifBlank { "self" }}",
                audioID = "audio-${targetName.lowercase().replace(seedNameSanitizer, "-").trim('-').ifBlank { "self" }}",
                videoID = "video-${targetName.lowercase().replace(seedNameSanitizer, "-").trim('-').ifBlank { "self" }}",
                islevel = normalizedLevel,
                isAdmin = normalizedLevel == "2",
                isHost = normalizedLevel == "2",
                name = targetName,
                videoOn = parameters.videoAlreadyOn,
                audioOn = parameters.audioAlreadyOn,
                extra = buildJsonObject {
                    put("placeholder", JsonPrimitive(true))
                    put("source", JsonPrimitive("immediate-hydration"))
                }
            )

            println("MediaSFU - initializeMediaStateAfterValidation: injecting placeholder participant for $targetName")
            room.updateParticipants(listOf(placeholderParticipant))
            parameters.refParticipants = listOf(placeholderParticipant)
            effectiveParticipants = listOf(placeholderParticipant)
        }

        // Seed placeholder streams if needed (only if we don't have real streams yet)
        val existingStreams = parameters.allVideoStreamsState
        val shouldSeedPlaceholders = existingStreams.isEmpty() || existingStreams.all { stream ->
            stream.extra["placeholder"] == JsonPrimitive(true)
        }

        if (shouldSeedPlaceholders) {
            val placeholderStreams = buildPlaceholderStreams(effectiveParticipants)
            if (placeholderStreams.isNotEmpty()) {
                println("MediaSFU - initializeMediaStateAfterValidation: seeding ${placeholderStreams.size} placeholder streams")
                parameters.updateAllVideoStreams(placeholderStreams)
                parameters.updateOldAllStreams(placeholderStreams)
                parameters.updateNewLimitedStreams(placeholderStreams)
                parameters.updateNewLimitedStreamsIDs(
                    placeholderStreams
                        .map { stream -> stream.id ?: stream.producerId }
                        .distinct()
                )

                streams.updateStreamNames(placeholderStreams)
                streams.updateCurrentStreams(placeholderStreams)
                streams.updatePaginatedStreams(listOf(placeholderStreams))
                streams.updateNonAlVideoStreams(placeholderStreams)
                streams.updateMixedAlVideoStreams(emptyList())
                streams.updateNonAlVideoStreamsMuted(placeholderStreams.filter { it.muted == true })
                streams.updateAllAudioStreams(placeholderStreams)
                streams.updateRemoteScreenStreams(emptyList())
                streams.updateLStreams(placeholderStreams)
                streams.updateChatRefStreams(emptyList())
                val placeholderNames = effectiveParticipants.map(Participant::name)
                streams.updateActiveNames(placeholderNames)
                streams.updatePrevActiveNames(placeholderNames)
                streams.updatePActiveNames(placeholderNames)
                streams.updateDispActiveNames(placeholderNames)
                streams.updatePDispActiveNames(placeholderNames)
                streams.updateMainScreenPerson(targetName)
                streams.updateMainScreenFilled(true)
                streams.updateAdminOnMainScreen(
                    effectiveParticipants.firstOrNull()?.let { it.isHost || it.isAdmin } == true
                )
                streams.updateGotAllVids(true)

                if (!display.showMiniView) {
                    display.updateShowMiniView(true)
                }
            } else {
                println("MediaSFU - initializeMediaStateAfterValidation: no placeholder streams derived")
            }
        } else {
            println("MediaSFU - initializeMediaStateAfterValidation: existing non-placeholder streams present=${existingStreams.size}")
        }

        println("MediaSFU - initializeMediaStateAfterValidation: targetName=$targetName")
        try {
            val prepopulateOptions = PrepopulateUserMediaOptions(
                name = targetName,
                parameters = parameters
            )
            parameters.prepopulateUserMedia.invoke(prepopulateOptions)
            println("MediaSFU - initializeMediaStateAfterValidation: prepopulate invoked")
        } catch (error: Throwable) {
            println("MediaSFU - initializeMediaStateAfterValidation: prepopulate failed -> ${error.message}")
        }

        try {
            val reorderOptions = ReorderStreamsOptions(
                add = false,
                screenChanged = false,
                parameters = parameters,
                streams = emptyList()
            )
            parameters.reorderStreams.invoke(reorderOptions)
            println("MediaSFU - initializeMediaStateAfterValidation: reorder invoked")
        } catch (error: Throwable) {
            println("MediaSFU - initializeMediaStateAfterValidation: reorder failed -> ${error.message}")
        }

        propagateParameterChanges()
        println("MediaSFU - initializeMediaStateAfterValidation: propagateParameterChanges completed")

        val hasRealParticipants = parameters.participants.any { participant ->
            participant.extra["placeholder"] != JsonPrimitive(true)
        }

        if (hasRealParticipants) {
            initialMediaHydrated = true
            println("MediaSFU - initializeMediaStateAfterValidation: hydration marked complete")
        } else {
            println("MediaSFU - initializeMediaStateAfterValidation: awaiting real participants before finalizing hydration")
        }
    }

    private suspend fun JoinRoomClientOptions.joinMediaSFURoom(): ResponseJoinRoom {
        return try {
            options.joinMediaSFURoom(this)
        } catch (error: Throwable) {
            throw IllegalStateException(
                "Failed to join room: ${error.message ?: "unknown error"}",
                error
            )
        }
    }

    private inner class UpdateRoomParametersBridge : UpdateRoomParametersClientParameters {
        override val rtpCapabilities get() = parameters.rtpCapabilities
        override val roomRecvIPs get() = parameters.roomRecvIPs
        override val meetingRoomParams get() = parameters.meetingRoomParams
        override val itemPageLimit get() = media.itemPageLimit
        override val audioOnlyRoom get() = media.audioOnlyRoom
        override val addForBasic get() = media.addForBasic
        override val screenPageLimit get() = media.screenPageLimit
        override val shareScreenStarted get() = media.shareScreenStarted
        override val shared get() = media.shared
        override val targetOrientation get() = media.targetOrientation
        override val vidCons get() = parameters.vidCons
        override val recordingVideoSupport get() = parameters.recordingVideoSupport
        override val frameRate get() = media.frameRate
        override val adminPasscode get() = room.adminPasscode
        override val eventType get() = room.eventType
        override val youAreCoHost get() = room.youAreCoHost
        override val autoWave get() = parameters.autoWave
        override val forceFullDisplay get() = parameters.forceFullDisplay
        override val chatSetting get() = media.chatSetting
        override val meetingDisplayType get() = room.meetingDisplayType
        override val audioSetting get() = media.audioSetting
        override val videoSetting get() = media.videoSetting
        override val screenshareSetting get() = media.screenshareSetting
        override val hParams get() = parameters.hParams
        override val vParams get() = parameters.vParams
        override val screenParams get() = parameters.screenParams
        override val aParams get() = parameters.aParams
        override val islevel get() = room.islevel
        override val showAlert: ShowAlert?
            get() = ShowAlert { message, type, duration ->
                this@MediasfuGenericState.showAlert(message, type, duration)
            }
        override val roomData get() = parameters.roomData

        override val updateRtpCapabilities: UpdateRtpCapabilities
            get() = { value ->
                media.rtpCapabilities = value
                parameters.rtpCapabilities = value
                notifyParametersChanged()

                if (value != null) {
                    println(
                        "MediaSFU - updateRtpCapabilities: codecs=${value.codecs.map { it.mimeType }}"
                    )
                    val currentDevice = parameters.device
                    if (currentDevice != null) {
                        launchInScope {
                            currentDevice
                                .load(value)
                                .onSuccess {
                                    println("MediaSFU - updateRtpCapabilities: device loaded")
                                }
                                .onFailure { error ->
                                    println(
                                        "MediaSFU - updateRtpCapabilities: device load failed -> ${error.message}"
                                    )
                                }
                        }
                    }
                }
            }

        override val updateRoomRecvIPs: UpdateRoomRecvIPs
            get() = { value ->
                parameters.roomRecvIPs = value
                notifyParametersChanged()
            }

        override val updateMeetingRoomParams: UpdateMeetingRoomParams
            get() = { value ->
                media.meetingRoomParams = value
                parameters.meetingRoomParams = value
                notifyParametersChanged()
            }

        override val updateItemPageLimit: UpdateItemPageLimit
            get() = { value ->
                media.itemPageLimit = value
                parameters.itemPageLimit = value
                notifyParametersChanged()
            }

        override val updateAudioOnlyRoom: UpdateAudioOnlyRoom
            get() = { value ->
                media.audioOnlyRoom = value
                parameters.audioOnlyRoom = value
                notifyParametersChanged()
            }

        override val updateAddForBasic: UpdateAddForBasic
            get() = { value ->
                media.addForBasic = value
                parameters.addForBasic = value
                notifyParametersChanged()
            }

        override val updateScreenPageLimit: UpdateScreenPageLimit
            get() = { value ->
                media.screenPageLimit = value
                parameters.screenPageLimit = value
                notifyParametersChanged()
            }

        override val updateVidCons: UpdateVidCons
            get() = { value ->
                media.vidCons = value
                parameters.vidCons = value
                notifyParametersChanged()
            }

        override val updateFrameRate: UpdateFrameRate
            get() = { value ->
                media.frameRate = value
                parameters.frameRate = value
                notifyParametersChanged()
            }

        override val updateAdminPasscode: UpdateAdminPasscode
            get() = { value -> room.updateAdminPasscode(value) }

        override val updateEventType: UpdateEventType
            get() = { value ->
                room.eventType = value
                parameters.eventType = value
                notifyParametersChanged()
            }

        override val updateYouAreCoHost: UpdateYouAreCoHost
            get() = { value ->
                room.youAreCoHost = value
                parameters.youAreCoHost = value
                notifyParametersChanged()
            }

        override val updateAutoWave: UpdateAutoWave
            get() = { value ->
                parameters.autoWave = value
                notifyParametersChanged()
            }

        override val updateForceFullDisplay: UpdateForceFullDisplay
            get() = { value ->
                parameters.forceFullDisplay = value
                notifyParametersChanged()
            }

        override val updateChatSetting: UpdateChatSetting
            get() = { value ->
                media.chatSetting = value
                parameters.chatSetting = value
                notifyParametersChanged()
            }

        override val updateMeetingDisplayType: UpdateMeetingDisplayType
            get() = { value ->
                room.meetingDisplayType = value
                parameters.meetingDisplayType = value
                notifyParametersChanged()
            }

        override val updateAudioSetting: UpdateAudioSetting
            get() = { value ->
                media.audioSetting = value
                parameters.audioSetting = value
                notifyParametersChanged()
            }

        override val updateVideoSetting: UpdateVideoSetting
            get() = { value ->
                media.videoSetting = value
                parameters.videoSetting = value
                notifyParametersChanged()
            }

        override val updateScreenshareSetting: UpdateScreenshareSetting
            get() = { value ->
                media.screenshareSetting = value
                parameters.screenshareSetting = value
                notifyParametersChanged()
            }

        override val updateHParams: UpdateHParams
            get() = { value ->
                parameters.hParams = value
                notifyParametersChanged()
            }

        override val updateVParams: UpdateVParams
            get() = { value ->
                parameters.vParams = value
                notifyParametersChanged()
            }

        override val updateScreenParams: UpdateScreenParams
            get() = { value ->
                parameters.screenParams = value
                notifyParametersChanged()
            }

        override val updateAParams: UpdateAParams
            get() = { value ->
                parameters.aParams = value
                notifyParametersChanged()
            }

        override val updateMainHeightWidth: UpdateMainHeightWidth
            get() = { value ->
                display.updateMainHeightWidth(value)
            }

        override val updateTargetResolution: UpdateTargetResolution
            get() = { value ->
                media.targetResolution = value
                parameters.targetResolution = value
                notifyParametersChanged()
            }

        override val updateTargetResolutionHost: UpdateTargetResolutionHost
            get() = { value ->
                media.targetResolutionHost = value
                parameters.targetResolutionHost = value
                notifyParametersChanged()
            }

        override val updateRecordingAudioPausesLimit: UpdateRecordingAudioPausesLimit
            get() = { value ->
                parameters.updateRecordingAudioPausesLimit(value)
                notifyParametersChanged()
            }

        override val updateRecordingAudioPausesCount: UpdateRecordingAudioPausesCount
            get() = { value ->
                parameters.updateRecordingAudioPausesCount(value)
                notifyParametersChanged()
            }

        override val updateRecordingAudioSupport: UpdateRecordingAudioSupport
            get() = { value ->
                recording.updateRecordingAudioSupport(value)
            }

        override val updateRecordingAudioPeopleLimit: UpdateRecordingAudioPeopleLimit
            get() = { value ->
                parameters.updateRecordingAudioPeopleLimit(value)
                notifyParametersChanged()
            }

        override val updateRecordingAudioParticipantsTimeLimit: UpdateRecordingAudioParticipantsTimeLimit
            get() = { value ->
                parameters.updateRecordingAudioParticipantsTimeLimit(value)
                notifyParametersChanged()
            }

        override val updateRecordingVideoPausesCount: UpdateRecordingVideoPausesCount
            get() = { value ->
                parameters.updateRecordingVideoPausesCount(value)
                notifyParametersChanged()
            }

        override val updateRecordingVideoPausesLimit: UpdateRecordingVideoPausesLimit
            get() = { value ->
                parameters.updateRecordingVideoPausesLimit(value)
                notifyParametersChanged()
            }

        override val updateRecordingVideoSupport: UpdateRecordingVideoSupport
            get() = { value ->
                recording.updateRecordingVideoSupport(value)
            }

        override val updateRecordingVideoPeopleLimit: UpdateRecordingVideoPeopleLimit
            get() = { value ->
                parameters.updateRecordingVideoPeopleLimit(value)
                notifyParametersChanged()
            }

        override val updateRecordingVideoParticipantsTimeLimit: UpdateRecordingVideoParticipantsTimeLimit
            get() = { value ->
                parameters.updateRecordingVideoParticipantsTimeLimit(value)
                notifyParametersChanged()
            }

        override val updateRecordingAllParticipantsSupport: UpdateRecordingAllParticipantsSupport
            get() = { value ->
                recording.updateRecordingAllParticipantsSupport(value)
            }

        override val updateRecordingVideoParticipantsSupport: UpdateRecordingVideoParticipantsSupport
            get() = { value ->
                recording.updateRecordingVideoParticipantsSupport(value)
            }

        override val updateRecordingAllParticipantsFullRoomSupport: UpdateRecordingAllParticipantsFullRoomSupport
            get() = { value ->
                parameters.updateRecordingAllParticipantsFullRoomSupport(value)
                notifyParametersChanged()
            }

        override val updateRecordingVideoParticipantsFullRoomSupport: UpdateRecordingVideoParticipantsFullRoomSupport
            get() = { value ->
                parameters.updateRecordingVideoParticipantsFullRoomSupport(value)
                notifyParametersChanged()
            }

        override val updateRecordingPreferredOrientation: UpdateRecordingPreferredOrientation
            get() = { value ->
                parameters.updateRecordingPreferredOrientation(value)
                parameters.updateRecordingOrientationVideo(value)
                notifyParametersChanged()
            }

        override val updateRecordingSupportForOtherOrientation: UpdateRecordingSupportForOtherOrientation
            get() = { value ->
                parameters.updateRecordingSupportForOtherOrientation(value)
                notifyParametersChanged()
            }

        override val updateRecordingMultiFormatsSupport: UpdateRecordingMultiFormatsSupport
            get() = { value ->
                parameters.updateRecordingMultiFormatsSupport(value)
                notifyParametersChanged()
            }

        override val updateRecordingVideoOptions: UpdateRecordingVideoOptions
            get() = { value ->
                recording.updateRecordingVideoOptions(value)
            }

        override val updateRecordingAudioOptions: UpdateRecordingAudioOptions
            get() = { value ->
                recording.updateRecordingAudioOptions(value)
            }

        override fun getUpdatedAllParams(): UpdateRoomParametersClientParameters = this
    }

    internal fun propagateParameterChanges() {
        room.refreshFromParameters()
        display.refreshFromParameters()
        streams.refreshFromParameters()
        recording.refreshFromParameters()
        polls.refreshFromParameters()
        requests.refreshFromParameters()
        notifyParametersChanged()
    }

    private fun notifyParametersChanged() {
        options.updateSourceParameters?.invoke(parameters)
    }
}

// ---------------------------------------------------------------------------
// State slices (grouping related data similar to Flutter implementation)
// ---------------------------------------------------------------------------

class ConnectivityState(
    private val parameters: MediasfuParameters,
    private val notifier: () -> Unit
) {
    var socket: SocketManager? by mutableStateOf(parameters.socket)
        private set

    var localSocket: SocketManager? by mutableStateOf(parameters.localSocket)
        private set

    var device: WebRtcDevice? by mutableStateOf(parameters.device)
        private set

    var roomResponse: ResponseJoinRoom by mutableStateOf(parameters.roomData)
        private set

    fun updateSocket(value: SocketManager?) {
        if (socket === value) return
        socket = value
        parameters.socket = value
        notifier()
    }

    fun updateLocalSocket(value: SocketManager?) {
        if (localSocket === value) return
        localSocket = value
        parameters.localSocket = value
        notifier()
    }

    fun updateDevice(value: WebRtcDevice?) {
        if (device === value) return
        device = value
        parameters.device = value
        notifier()
    }

    fun updateRoomResponse(value: ResponseJoinRoom) {
        if (roomResponse == value) return
        roomResponse = value
        parameters.roomData = value
        notifier()
    }

    fun clearConnections() {
        updateSocket(null)
        updateLocalSocket(null)
    }
}

class RoomState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    var apiKey by mutableStateOf(parameters.apiKey)
    var apiUserName by mutableStateOf(parameters.apiUserName)
    var apiToken by mutableStateOf(parameters.apiToken)
    var link by mutableStateOf(parameters.link)

    var roomName by mutableStateOf(parameters.roomName)
        private set
    var member by mutableStateOf(parameters.member)
        private set
    var adminPasscode by mutableStateOf(parameters.adminPasscode)
        private set
    var islevel by mutableStateOf(parameters.islevel)
        private set
    var coHost by mutableStateOf(parameters.coHost)
    var youAreCoHost by mutableStateOf(parameters.youAreCoHost)
    var youAreHost by mutableStateOf(parameters.youAreHost)
    var confirmedToRecord by mutableStateOf(parameters.confirmedToRecord)

    var meetingDisplayType by mutableStateOf(parameters.meetingDisplayType)
    var meetingVideoOptimized by mutableStateOf(parameters.meetingVideoOptimized)
    var eventType by mutableStateOf(parameters.eventType)

    val participants = mutableStateListOf<Participant>().apply {
        addAll(parameters.participants)
    }
    val filteredParticipants = mutableStateListOf<Participant>().apply {
        addAll(parameters.filteredParticipants.ifEmpty { parameters.participants })
    }

    var participantsCounter by mutableStateOf(parameters.participantsCounter)
    var participantsFilter by mutableStateOf(parameters.participantsFilter)

    var coHostResponsibility by mutableStateOf(parameters.coHostResponsibility)
    var adminRestrictSetting by mutableStateOf(parameters.adminRestrictSetting)

    fun updateRoomName(value: String) {
        roomName = value
        parameters.roomName = value
        notifier()
    }

    fun updateMember(value: String) {
        member = value
        parameters.member = value
        notifier()
    }

    fun updateAdminPasscode(value: String) {
        adminPasscode = value
        parameters.adminPasscode = value
        notifier()
    }

    fun updateIslevel(value: String) {
        islevel = value
        parameters.islevel = value
        notifier()
    }

    fun updateApiKey(value: String) {
        apiKey = value
        parameters.apiKey = value
        notifier()
    }

    fun updateApiUserName(value: String) {
        apiUserName = value
        parameters.apiUserName = value
        notifier()
    }

    fun updateApiToken(value: String) {
        apiToken = value
        parameters.apiToken = value
        notifier()
    }

    fun updateLink(value: String) {
        link = value
        parameters.link = value
        notifier()
    }

    fun updateCoHost(value: String) {
        if (coHost == value) return
        coHost = value
        parameters.coHost = value
        notifier()
    }

    fun updateCoHostResponsibility(value: List<ModelCoHostResponsibility>) {
        if (coHostResponsibility == value) return
        coHostResponsibility = value
        parameters.coHostResponsibility = value
        notifier()
    }

    fun updateConfirmedToRecord(value: Boolean) {
        if (confirmedToRecord == value) return
        confirmedToRecord = value
        parameters.updateConfirmedToRecord(value)
        notifier()
    }

    fun updateRoomData(value: ResponseJoinRoom) {
        parameters.roomData = value
        notifier()
    }

    fun updateParticipants(newParticipants: List<Participant>) {
        participants.clear()
        participants.addAll(newParticipants)
        parameters.participants = newParticipants
        updateFilteredParticipants(newParticipants)
        participantsCounter = newParticipants.size
        parameters.participantsCounter = participantsCounter
        notifier()
    }

    fun updateFilteredParticipants(newFiltered: List<Participant>) {
        filteredParticipants.clear()
        filteredParticipants.addAll(newFiltered)
        parameters.filteredParticipants = newFiltered
        participantsCounter = newFiltered.size
        parameters.participantsCounter = participantsCounter
        notifier()
    }

    fun updateAudioSetting(setting: String) {
        parameters.audioSetting = setting
        notifier()
    }

    fun updateVideoSetting(setting: String) {
        parameters.videoSetting = setting
        notifier()
    }

    fun updateScreenshareSetting(setting: String) {
        parameters.screenshareSetting = setting
        notifier()
    }

    fun updateChatSetting(setting: String) {
        parameters.chatSetting = setting
        notifier()
    }

    fun refreshFromParameters() {
        if (apiKey != parameters.apiKey) {
            apiKey = parameters.apiKey
        }
        if (apiUserName != parameters.apiUserName) {
            apiUserName = parameters.apiUserName
        }
        if (apiToken != parameters.apiToken) {
            apiToken = parameters.apiToken
        }
        if (link != parameters.link) {
            link = parameters.link
        }
        if (roomName != parameters.roomName) {
            roomName = parameters.roomName
        }
        if (member != parameters.member) {
            member = parameters.member
        }
        if (adminPasscode != parameters.adminPasscode) {
            adminPasscode = parameters.adminPasscode
        }
        if (islevel != parameters.islevel) {
            islevel = parameters.islevel
        }
        if (coHost != parameters.coHost) {
            coHost = parameters.coHost
        }
        if (youAreCoHost != parameters.youAreCoHost) {
            youAreCoHost = parameters.youAreCoHost
        }
        if (youAreHost != parameters.youAreHost) {
            youAreHost = parameters.youAreHost
        }
        if (confirmedToRecord != parameters.confirmedToRecord) {
            confirmedToRecord = parameters.confirmedToRecord
        }
        if (meetingDisplayType != parameters.meetingDisplayType) {
            meetingDisplayType = parameters.meetingDisplayType
        }
        if (meetingVideoOptimized != parameters.meetingVideoOptimized) {
            meetingVideoOptimized = parameters.meetingVideoOptimized
        }
        if (eventType != parameters.eventType) {
            eventType = parameters.eventType
        }
        if (coHostResponsibility != parameters.coHostResponsibility) {
            coHostResponsibility = parameters.coHostResponsibility
        }

        participants.syncWith(parameters.participants)

        val resolvedFilter = parameters.participantsFilter
        val filteredSource = when {
            parameters.filteredParticipants.isNotEmpty() -> parameters.filteredParticipants
            resolvedFilter.isNotBlank() -> parameters.participants.filter { participant ->
                participant.name.contains(resolvedFilter, ignoreCase = true)
            }
            else -> parameters.participants
        }
        filteredParticipants.syncWith(filteredSource)

        if (participantsFilter != resolvedFilter) {
            participantsFilter = resolvedFilter
        }

        val newCounter = if (parameters.participantsCounter > filteredSource.size) {
            parameters.participantsCounter
        } else {
            filteredSource.size
        }
        if (participantsCounter != newCounter) {
            participantsCounter = newCounter
        }
    }

    private fun <T> MutableList<T>.syncWith(values: List<T>) {
        if (this == values) return
        clear()
        addAll(values)
    }
}

class MediaState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    var consumeSockets by mutableStateOf(parameters.consumeSocketsState)
    var rtpCapabilities by mutableStateOf(parameters.rtpCapabilities)
    var meetingRoomParams by mutableStateOf(parameters.meetingRoomParams)
    var itemPageLimit by mutableStateOf(parameters.itemPageLimit)
    var audioOnlyRoom by mutableStateOf(parameters.audioOnlyRoom)
    var addForBasic by mutableStateOf(parameters.addForBasic)
    var screenPageLimit by mutableStateOf(parameters.screenPageLimit)
    var shareScreenStarted by mutableStateOf(parameters.shareScreenStarted)
    var shared by mutableStateOf(parameters.shared)
    var targetOrientation by mutableStateOf(parameters.targetOrientation)
    var targetResolution by mutableStateOf(parameters.targetResolution)
    var targetResolutionHost by mutableStateOf(parameters.targetResolutionHost)
    var vidCons by mutableStateOf(parameters.vidCons)
    var frameRate by mutableStateOf(parameters.frameRate)

    var videoAlreadyOn by mutableStateOf(parameters.videoAlreadyOn)
    var audioAlreadyOn by mutableStateOf(parameters.audioAlreadyOn)
    var screenAlreadyOn by mutableStateOf(parameters.screenAlreadyOn)

    var audioSetting by mutableStateOf(parameters.audioSetting)
    var videoSetting by mutableStateOf(parameters.videoSetting)
    var screenshareSetting by mutableStateOf(parameters.screenshareSetting)
    var chatSetting by mutableStateOf(parameters.chatSetting)

    var screenRequestState by mutableStateOf(parameters.screenRequestState)

    fun updateTargetOrientation(value: String) {
        targetOrientation = value
        parameters.targetOrientation = value
        notifier()
    }

    fun updateAudioSetting(value: String) {
        if (audioSetting == value) return
        audioSetting = value
        parameters.audioSetting = value
        notifier()
    }

    fun updateVideoSetting(value: String) {
        if (videoSetting == value) return
        videoSetting = value
        parameters.videoSetting = value
        notifier()
    }

    fun updateScreenshareSetting(value: String) {
        if (screenshareSetting == value) return
        screenshareSetting = value
        parameters.screenshareSetting = value
        notifier()
    }

    fun updateChatSetting(value: String) {
        if (chatSetting == value) return
        chatSetting = value
        parameters.chatSetting = value
        notifier()
    }
}

class DisplayState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    var controlHeight by mutableStateOf(parameters.controlHeight)
        private set
    var paginationHeightWidth by mutableStateOf(parameters.paginationHeightWidth)
        private set
    var paginationDirection by mutableStateOf(parameters.paginationDirection)
        private set
    var gridSizes by mutableStateOf(parameters.gridSizes)
        private set
    var componentSizes by mutableStateOf(parameters.componentSizes)
        private set
    var isWideScreen by mutableStateOf(parameters.isWideScreen)
        private set
    var isMediumScreen by mutableStateOf(parameters.isMediumScreen)
        private set
    var isSmallScreen by mutableStateOf(parameters.isSmallScreen)
        private set
    var addGrid by mutableStateOf(parameters.addGrid)
        private set
    var addAltGrid by mutableStateOf(parameters.addAltGrid)
        private set
    var gridRows by mutableStateOf(parameters.gridRows)
        private set
    var gridCols by mutableStateOf(parameters.gridCols)
        private set
    var altGridRows by mutableStateOf(parameters.altGridRows)
        private set
    var altGridCols by mutableStateOf(parameters.altGridCols)
        private set
    var numberPages by mutableStateOf(parameters.numberPages)
        private set
    var currentUserPage by mutableStateOf(parameters.currentUserPage)
        private set
    var showMiniView by mutableStateOf(parameters.showMiniView)
        private set
    var doPaginate by mutableStateOf(parameters.doPaginate)
        private set
    var prevDoPaginate by mutableStateOf(parameters.prevDoPaginate)
        private set
    var mainHeightWidth by mutableStateOf(parameters.mainHeightWidth)
        private set
    var prevMainHeightWidth by mutableStateOf(parameters.prevMainHeightWidth)
        private set
    var screenForceFullDisplay by mutableStateOf(parameters.screenForceFullDisplay)
        private set

    // Display settings properties
    var meetingDisplayType by mutableStateOf(parameters.meetingDisplayType)
    var autoWave by mutableStateOf(parameters.autoWave)
    var forceFullDisplay by mutableStateOf(parameters.forceFullDisplay)
    var meetingVideoOptimized by mutableStateOf(parameters.meetingVideoOptimized)
    var prevMeetingDisplayType by mutableStateOf(parameters.prevMeetingDisplayType)

    fun updateControlHeight(value: Double) {
        if (controlHeight == value) return
        controlHeight = value
        parameters.controlHeight = value
        notifier()
    }

    fun updatePaginationHeightWidth(value: Double) {
        if (paginationHeightWidth == value) return
        paginationHeightWidth = value
        parameters.paginationHeightWidth = value
        notifier()
    }

    fun updatePaginationDirection(value: String) {
        if (paginationDirection == value) return
        paginationDirection = value
        parameters.paginationDirection = value
        notifier()
    }

    fun updateGridSizes(value: GridSizes) {
        if (gridSizes == value) return
        gridSizes = value
        parameters.gridSizes = value
        notifier()
    }

    fun updateComponentSizes(value: ComponentSizes) {
        if (componentSizes == value) return
        componentSizes = value
        parameters.componentSizes = value
        notifier()
    }

    fun updateGridRows(value: Int) {
        if (gridRows == value) return
        gridRows = value
        parameters.gridRows = value
        notifier()
    }

    fun updateGridCols(value: Int) {
        if (gridCols == value) return
        gridCols = value
        parameters.gridCols = value
        notifier()
    }

    fun updateAltGridRows(value: Int) {
        if (altGridRows == value) return
        altGridRows = value
        parameters.altGridRows = value
        notifier()
    }

    fun updateAltGridCols(value: Int) {
        if (altGridCols == value) return
        altGridCols = value
        parameters.altGridCols = value
        notifier()
    }

    fun updateNumberPages(value: Int) {
        if (numberPages == value) return
        numberPages = value
        parameters.numberPages = value
        notifier()
    }

    fun updateCurrentUserPage(value: Int) {
        if (currentUserPage == value) return
        currentUserPage = value
        parameters.currentUserPage = value
        notifier()
    }

    fun updateShowMiniView(value: Boolean) {
        if (showMiniView == value) return
        showMiniView = value
        parameters.showMiniView = value
        notifier()
    }

    fun updateDoPaginate(value: Boolean) {
        if (doPaginate == value) return
        doPaginate = value
        parameters.doPaginate = value
        notifier()
    }

    fun updatePrevDoPaginate(value: Boolean) {
        if (prevDoPaginate == value) return
        prevDoPaginate = value
        parameters.prevDoPaginate = value
        notifier()
    }

    fun updateMainHeightWidth(value: Double) {
        if (mainHeightWidth == value) return
        mainHeightWidth = value
        parameters.mainHeightWidth = value
        notifier()
    }

    fun updatePrevMainHeightWidth(value: Double) {
        if (prevMainHeightWidth == value) return
        prevMainHeightWidth = value
        parameters.prevMainHeightWidth = value
        notifier()
    }

    fun updateScreenForceFullDisplay(value: Boolean) {
        if (screenForceFullDisplay == value) return
        screenForceFullDisplay = value
        parameters.screenForceFullDisplay = value
        notifier()
    }

    fun updateMeetingDisplayType(value: String) {
        if (meetingDisplayType == value) return
        meetingDisplayType = value
        parameters.meetingDisplayType = value
        notifier()
    }

    fun updateAutoWave(value: Boolean) {
        if (autoWave == value) return
        autoWave = value
        parameters.autoWave = value
        notifier()
    }

    fun updateForceFullDisplay(value: Boolean) {
        if (forceFullDisplay == value) return
        forceFullDisplay = value
        parameters.forceFullDisplay = value
        notifier()
    }

    fun updateMeetingVideoOptimized(value: Boolean) {
        if (meetingVideoOptimized == value) return
        meetingVideoOptimized = value
        parameters.meetingVideoOptimized = value
        notifier()
    }

    fun setWideScreenFlag(value: Boolean) {
        if (isWideScreen == value) return
        isWideScreen = value
        parameters.isWideScreen = value
        notifier()
    }

    fun setMediumScreenFlag(value: Boolean) {
        if (isMediumScreen == value) return
        isMediumScreen = value
        parameters.isMediumScreen = value
        notifier()
    }

    fun setSmallScreenFlag(value: Boolean) {
        if (isSmallScreen == value) return
        isSmallScreen = value
        parameters.isSmallScreen = value
        notifier()
    }

    fun setAddGridEnabled(value: Boolean) {
        if (addGrid == value) return
        addGrid = value
        parameters.addGrid = value
        notifier()
    }

    fun setAddAltGridEnabled(value: Boolean) {
        if (addAltGrid == value) return
        addAltGrid = value
        parameters.addAltGrid = value
        notifier()
    }

    fun refreshFromParameters() {
        if (controlHeight != parameters.controlHeight) {
            controlHeight = parameters.controlHeight
        }
        if (paginationHeightWidth != parameters.paginationHeightWidth) {
            paginationHeightWidth = parameters.paginationHeightWidth
        }
        if (paginationDirection != parameters.paginationDirection) {
            paginationDirection = parameters.paginationDirection
        }
        if (gridSizes != parameters.gridSizes) {
            gridSizes = parameters.gridSizes
        }
        if (componentSizes != parameters.componentSizes) {
            componentSizes = parameters.componentSizes
        }
        if (isWideScreen != parameters.isWideScreen) {
            isWideScreen = parameters.isWideScreen
        }
        if (isMediumScreen != parameters.isMediumScreen) {
            isMediumScreen = parameters.isMediumScreen
        }
        if (isSmallScreen != parameters.isSmallScreen) {
            isSmallScreen = parameters.isSmallScreen
        }
        if (addGrid != parameters.addGrid) {
            addGrid = parameters.addGrid
        }
        if (addAltGrid != parameters.addAltGrid) {
            addAltGrid = parameters.addAltGrid
        }
        if (gridRows != parameters.gridRows) {
            gridRows = parameters.gridRows
        }
        if (gridCols != parameters.gridCols) {
            gridCols = parameters.gridCols
        }
        if (altGridRows != parameters.altGridRows) {
            altGridRows = parameters.altGridRows
        }
        if (altGridCols != parameters.altGridCols) {
            altGridCols = parameters.altGridCols
        }
        if (numberPages != parameters.numberPages) {
            numberPages = parameters.numberPages
        }
        if (currentUserPage != parameters.currentUserPage) {
            currentUserPage = parameters.currentUserPage
        }
        if (showMiniView != parameters.showMiniView) {
            showMiniView = parameters.showMiniView
        }
        if (doPaginate != parameters.doPaginate) {
            doPaginate = parameters.doPaginate
        }
        if (prevDoPaginate != parameters.prevDoPaginate) {
            prevDoPaginate = parameters.prevDoPaginate
        }
        if (mainHeightWidth != parameters.mainHeightWidth) {
            mainHeightWidth = parameters.mainHeightWidth
        }
        if (prevMainHeightWidth != parameters.prevMainHeightWidth) {
            prevMainHeightWidth = parameters.prevMainHeightWidth
        }
        if (screenForceFullDisplay != parameters.screenForceFullDisplay) {
            screenForceFullDisplay = parameters.screenForceFullDisplay
        }
    }
}

class StreamsState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    private val streamNamesState = mutableStateListOf<Stream>().apply { addAll(parameters.streamNames) }
    private val currentStreamsState = mutableStateListOf<Stream>().apply { addAll(parameters.currentStreams) }
    private val paginatedStreamsState = mutableStateListOf<List<Stream>>().apply { addAll(parameters.paginatedStreams) }
    private val nonAlVideoStreamsState = mutableStateListOf<Stream>().apply { addAll(parameters.nonAlVideoStreams) }
    private val mixedAlVideoStreamsState = mutableStateListOf<Stream>().apply { addAll(parameters.mixedAlVideoStreams) }
    private val nonAlVideoStreamsMutedState = mutableStateListOf<Stream>().apply { addAll(parameters.nonAlVideoStreamsMuted) }
    private val allAudioStreamsState = mutableStateListOf<Stream>().apply { addAll(parameters.allAudioStreams) }
    private val remoteScreenStreamsState = mutableStateListOf<Stream>().apply { addAll(parameters.remoteScreenStreamState) }
    private val lStreamsState = mutableStateListOf<Stream>().apply { addAll(parameters.lStreams) }
    private val chatRefStreamsState = mutableStateListOf<Stream>().apply { addAll(parameters.chatRefStreams) }

    var mainScreenPerson by mutableStateOf(parameters.mainScreenPerson)
        private set
    var adminOnMainScreen by mutableStateOf(parameters.adminOnMainScreen)
        private set
    var mainScreenFilled by mutableStateOf(parameters.mainScreenFilled)
        private set
    var shareEnded by mutableStateOf(parameters.shareEnded)
        private set
    var gotAllVids by mutableStateOf(parameters.gotAllVids)
        private set
    var screenStates by mutableStateOf(parameters.screenStates)
        private set
    var prevScreenStates by mutableStateOf(parameters.prevScreenStates)
        private set
    var activeNames by mutableStateOf(parameters.activeNames)
        private set
    var prevActiveNames by mutableStateOf(parameters.prevActiveNames)
        private set
    var pActiveNames by mutableStateOf(parameters.pActiveNames)
        private set
    var dispActiveNames by mutableStateOf(parameters.dispActiveNames)
        private set
    var pDispActiveNames by mutableStateOf(parameters.pDispActiveNames)
        private set

    val streamNames: SnapshotStateList<Stream> get() = streamNamesState
    val currentStreams: SnapshotStateList<Stream> get() = currentStreamsState
    val paginatedStreams: SnapshotStateList<List<Stream>> get() = paginatedStreamsState
    val nonAlVideoStreams: SnapshotStateList<Stream> get() = nonAlVideoStreamsState
    val mixedAlVideoStreams: SnapshotStateList<Stream> get() = mixedAlVideoStreamsState
    val nonAlVideoStreamsMuted: SnapshotStateList<Stream> get() = nonAlVideoStreamsMutedState
    val allAudioStreams: SnapshotStateList<Stream> get() = allAudioStreamsState
    val remoteScreenStreams: SnapshotStateList<Stream> get() = remoteScreenStreamsState
    val lStreams: SnapshotStateList<Stream> get() = lStreamsState
    val chatRefStreams: SnapshotStateList<Stream> get() = chatRefStreamsState

    fun updateMainScreenPerson(value: String) {
        if (mainScreenPerson == value) return
        mainScreenPerson = value
        parameters.mainScreenPerson = value
        notifier()
    }

    fun updateAdminOnMainScreen(value: Boolean) {
        if (adminOnMainScreen == value) return
        adminOnMainScreen = value
        parameters.adminOnMainScreen = value
        notifier()
    }

    fun updateMainScreenFilled(value: Boolean) {
        if (mainScreenFilled == value) return
        mainScreenFilled = value
        parameters.mainScreenFilled = value
        notifier()
    }

    fun updateShareEnded(value: Boolean) {
        if (shareEnded == value) return
        shareEnded = value
        parameters.shareEnded = value
        notifier()
    }

    fun updateGotAllVids(value: Boolean) {
        if (gotAllVids == value) return
        gotAllVids = value
        parameters.gotAllVids = value
        notifier()
    }

    fun updateStreamNames(newNames: List<Stream>) {
        if (parameters.streamNames == newNames) return
        streamNamesState.replaceAll(newNames)
        parameters.streamNames = newNames
        notifier()
    }

    fun updateCurrentStreams(newStreams: List<Stream>) {
        if (parameters.currentStreams == newStreams) return
        currentStreamsState.replaceAll(newStreams)
        parameters.currentStreams = newStreams
        notifier()
    }

    fun updatePaginatedStreams(newStreams: List<List<Stream>>) {
        if (parameters.paginatedStreams == newStreams) return
        paginatedStreamsState.replaceAll(newStreams)
        parameters.paginatedStreams = newStreams
        notifier()
    }

    fun updateNonAlVideoStreams(newStreams: List<Stream>) {
        if (parameters.nonAlVideoStreams == newStreams) return
        nonAlVideoStreamsState.replaceAll(newStreams)
        parameters.nonAlVideoStreams = newStreams
        notifier()
    }

    fun updateMixedAlVideoStreams(newStreams: List<Stream>) {
        if (parameters.mixedAlVideoStreams == newStreams) return
        mixedAlVideoStreamsState.replaceAll(newStreams)
        parameters.mixedAlVideoStreams = newStreams
        notifier()
    }

    fun updateNonAlVideoStreamsMuted(newStreams: List<Stream>) {
        if (parameters.nonAlVideoStreamsMuted == newStreams) return
        nonAlVideoStreamsMutedState.replaceAll(newStreams)
        parameters.nonAlVideoStreamsMuted = newStreams
        notifier()
    }

    fun updateAllAudioStreams(newStreams: List<Stream>) {
        if (parameters.allAudioStreams == newStreams) return
        allAudioStreamsState.replaceAll(newStreams)
        parameters.allAudioStreams = newStreams
        notifier()
    }

    fun updateRemoteScreenStreams(newStreams: List<Stream>) {
        if (parameters.remoteScreenStreamState == newStreams) return
        remoteScreenStreamsState.replaceAll(newStreams)
        parameters.remoteScreenStreamState = newStreams
        notifier()
    }

    fun updateLStreams(newStreams: List<Stream>) {
        if (parameters.lStreams == newStreams) return
        lStreamsState.replaceAll(newStreams)
        parameters.lStreams = newStreams
        notifier()
    }

    fun updateChatRefStreams(newStreams: List<Stream>) {
        if (parameters.chatRefStreams == newStreams) return
        chatRefStreamsState.replaceAll(newStreams)
        parameters.chatRefStreams = newStreams
        notifier()
    }

    fun updateScreenStates(newStates: List<ScreenState>) {
        if (screenStates == newStates) return
        screenStates = newStates
        parameters.screenStates = newStates
        notifier()
    }

    fun updatePrevScreenStates(newStates: List<ScreenState>) {
        if (prevScreenStates == newStates) return
        prevScreenStates = newStates
        parameters.prevScreenStates = newStates
        notifier()
    }

    fun updateActiveNames(newNames: List<String>) {
        if (activeNames == newNames) return
        activeNames = newNames
        parameters.activeNames = newNames
        notifier()
    }

    fun updatePrevActiveNames(newNames: List<String>) {
        if (prevActiveNames == newNames) return
        prevActiveNames = newNames
        parameters.prevActiveNames = newNames
        notifier()
    }

    fun updatePActiveNames(newNames: List<String>) {
        if (pActiveNames == newNames) return
        pActiveNames = newNames
        parameters.pActiveNames = newNames
        notifier()
    }

    fun updateDispActiveNames(newNames: List<String>) {
        if (dispActiveNames == newNames) return
        dispActiveNames = newNames
        parameters.dispActiveNames = newNames
        notifier()
    }

    fun updatePDispActiveNames(newNames: List<String>) {
        if (pDispActiveNames == newNames) return
        pDispActiveNames = newNames
        parameters.pDispActiveNames = newNames
        notifier()
    }

    private fun <T> MutableList<T>.replaceAll(values: List<T>) {
        clear()
        addAll(values)
    }

    private fun <T> MutableList<T>.syncWith(values: List<T>) {
        if (this == values) return
        clear()
        addAll(values)
    }

    fun refreshFromParameters() {
        streamNamesState.syncWith(parameters.streamNames)
        currentStreamsState.syncWith(parameters.currentStreams)
        paginatedStreamsState.syncWith(parameters.paginatedStreams)
        nonAlVideoStreamsState.syncWith(parameters.nonAlVideoStreams)
        mixedAlVideoStreamsState.syncWith(parameters.mixedAlVideoStreams)
        nonAlVideoStreamsMutedState.syncWith(parameters.nonAlVideoStreamsMuted)
        allAudioStreamsState.syncWith(parameters.allAudioStreams)
        remoteScreenStreamsState.syncWith(parameters.remoteScreenStreamState)
        lStreamsState.syncWith(parameters.lStreams)
        chatRefStreamsState.syncWith(parameters.chatRefStreams)

        if (mainScreenPerson != parameters.mainScreenPerson) {
            mainScreenPerson = parameters.mainScreenPerson
        }
        if (adminOnMainScreen != parameters.adminOnMainScreen) {
            adminOnMainScreen = parameters.adminOnMainScreen
        }
        if (mainScreenFilled != parameters.mainScreenFilled) {
            mainScreenFilled = parameters.mainScreenFilled
        }
        if (shareEnded != parameters.shareEnded) {
            shareEnded = parameters.shareEnded
        }
        if (gotAllVids != parameters.gotAllVids) {
            gotAllVids = parameters.gotAllVids
        }
        if (screenStates != parameters.screenStates) {
            screenStates = parameters.screenStates
        }
        if (prevScreenStates != parameters.prevScreenStates) {
            prevScreenStates = parameters.prevScreenStates
        }
        if (activeNames != parameters.activeNames) {
            activeNames = parameters.activeNames
        }
        if (prevActiveNames != parameters.prevActiveNames) {
            prevActiveNames = parameters.prevActiveNames
        }
        if (pActiveNames != parameters.pActiveNames) {
            pActiveNames = parameters.pActiveNames
        }
        if (dispActiveNames != parameters.dispActiveNames) {
            dispActiveNames = parameters.dispActiveNames
        }
        if (pDispActiveNames != parameters.pDispActiveNames) {
            pDispActiveNames = parameters.pDispActiveNames
        }
    }
}

private class MediasfuPageContentParameters(
    private val backing: MediasfuParameters,
    private val state: MediasfuGenericState
) : GeneratePageContentParameters {
    override val paginatedStreams: List<List<Any>>
        get() = backing.paginatedStreams.map { streamList -> streamList.map { it as Any } }

    override val updateCurrentUserPage: (Int) -> Unit
        get() = { value -> state.display.updateCurrentUserPage(value) }

    override val dispStreams: suspend (DispStreamsOptions) -> Unit
        get() = { options -> com.mediasfu.sdk.consumers.dispStreams(options) }

    override fun getUpdatedAllParams(): GeneratePageContentParameters = this

    override val lStreams: List<Stream>
        get() = backing.lStreams

    override val participants: List<Participant>
        get() = backing.participants

    override val refParticipants: List<Participant>
        get() = backing.refParticipants

    override val currentUserPage: Int
        get() = backing.currentUserPage

    override val hostLabel: String
        get() = backing.hostLabel

    override val mainHeightWidth: Double
        get() = backing.mainHeightWidth

    override val updateMainWindow: Boolean
        get() = backing.updateMainWindow

    override val shared: Boolean
        get() = backing.shared

    override val shareScreenStarted: Boolean
        get() = backing.shareScreenStarted

    override val eventType: EventType
        get() = backing.eventType

    override val islevel: String
        get() = backing.islevel

    override val member: String
        get() = backing.member

    override val updateLStreams: (List<Stream>) -> Unit
        get() = { value -> state.streams.updateLStreams(value) }

    override val updateUpdateMainWindow: (Boolean) -> Unit
        get() = { value ->
            if (backing.updateMainWindow != value) {
                backing.updateMainWindow = value
                state.propagateParameterChanges()
            }
        }
}

class RecordingState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    var recordingMediaOptions by mutableStateOf(parameters.recordingMediaOptions)
    var recordingAudioOptions by mutableStateOf(parameters.recordingAudioOptions)
    var recordingVideoOptions by mutableStateOf(parameters.recordingVideoOptions)
    var recordingVideoType by mutableStateOf(parameters.recordingVideoType)
    var recordingVideoOptimized by mutableStateOf(parameters.recordingVideoOptimized)
    var recordingDisplayType by mutableStateOf(parameters.recordingDisplayType)
    var recordingAddHLS by mutableStateOf(parameters.recordingAddHLS)
    var recordState by mutableStateOf(parameters.recordState)
    var showRecordButtons by mutableStateOf(parameters.showRecordButtons)
    var recordingProgressTime by mutableStateOf(parameters.recordingProgressTime)

    var recordStarted by mutableStateOf(parameters.recordStarted)
    var recordPaused by mutableStateOf(parameters.recordPaused)
    var recordResumed by mutableStateOf(parameters.recordResumed)
    var recordStopped by mutableStateOf(parameters.recordStopped)
    var recordingAudioSupport by mutableStateOf(parameters.recordingAudioSupport)
    var recordingVideoSupport by mutableStateOf(parameters.recordingVideoSupport)
    var recordingAllParticipantsSupport by mutableStateOf(parameters.recordingAllParticipantsSupport)
    var recordingVideoParticipantsSupport by mutableStateOf(parameters.recordingVideoParticipantsSupport)
    var canRecord by mutableStateOf(parameters.canRecord)
    var clearedToRecord by mutableStateOf(parameters.clearedToRecord)

    // Additional recording properties
    var recordingBackgroundColor by mutableStateOf(parameters.recordingBackgroundColor)
    var recordingNameTagsColor by mutableStateOf(parameters.recordingNameTagsColor)
    var recordingOrientationVideo by mutableStateOf(parameters.recordingOrientationVideo)
    var recordingNameTags by mutableStateOf(parameters.recordingNameTags)
    var recordingAddText by mutableStateOf(parameters.recordingAddText)
    var recordingCustomText by mutableStateOf(parameters.recordingCustomText)
    var recordingCustomTextPosition by mutableStateOf(parameters.recordingCustomTextPosition)
    var recordingCustomTextColor by mutableStateOf(parameters.recordingCustomTextColor)

    fun updateRecordingMediaOptions(value: String) {
        if (recordingMediaOptions == value) return
        recordingMediaOptions = value
        parameters.updateRecordingMediaOptions(value)
        notifier()
    }

    fun updateRecordingAudioOptions(value: String) {
        if (recordingAudioOptions == value) return
        recordingAudioOptions = value
        parameters.updateRecordingAudioOptions(value)
        notifier()
    }

    fun updateRecordingVideoOptions(value: String) {
        if (recordingVideoOptions == value) return
        recordingVideoOptions = value
        parameters.updateRecordingVideoOptions(value)
        notifier()
    }

    fun updateRecordingVideoType(value: String) {
        if (recordingVideoType == value) return
        recordingVideoType = value
        parameters.updateRecordingVideoType(value)
        notifier()
    }

    fun updateRecordingVideoOptimized(value: Boolean) {
        if (recordingVideoOptimized == value) return
        recordingVideoOptimized = value
        parameters.updateRecordingVideoOptimized(value)
        notifier()
    }

    fun updateRecordingDisplayType(value: String) {
        if (recordingDisplayType == value) return
        recordingDisplayType = value
        parameters.updateRecordingDisplayType(value)
        notifier()
    }

    fun updateRecordingAddHls(value: Boolean) {
        if (recordingAddHLS == value) return
        recordingAddHLS = value
        parameters.updateRecordingAddHls(value)
        notifier()
    }

    fun updateRecordingBackgroundColor(value: String) {
        if (recordingBackgroundColor == value) return
        recordingBackgroundColor = value
        parameters.recordingBackgroundColor = value
        notifier()
    }

    fun updateRecordingNameTagsColor(value: String) {
        if (recordingNameTagsColor == value) return
        recordingNameTagsColor = value
        parameters.recordingNameTagsColor = value
        notifier()
    }

    fun updateRecordingOrientationVideo(value: String) {
        if (recordingOrientationVideo == value) return
        recordingOrientationVideo = value
        parameters.recordingOrientationVideo = value
        notifier()
    }

    fun updateRecordingNameTags(value: Boolean) {
        if (recordingNameTags == value) return
        recordingNameTags = value
        parameters.recordingNameTags = value
        notifier()
    }

    fun updateRecordingAddText(value: Boolean) {
        if (recordingAddText == value) return
        recordingAddText = value
        parameters.recordingAddText = value
        notifier()
    }

    fun updateRecordingCustomText(value: String) {
        if (recordingCustomText == value) return
        recordingCustomText = value
        parameters.recordingCustomText = value
        notifier()
    }

    fun updateRecordingCustomTextPosition(value: String) {
        if (recordingCustomTextPosition == value) return
        recordingCustomTextPosition = value
        parameters.recordingCustomTextPosition = value
        notifier()
    }

    fun updateRecordingCustomTextColor(value: String) {
        if (recordingCustomTextColor == value) return
        recordingCustomTextColor = value
        parameters.recordingCustomTextColor = value
        notifier()
    }

    fun updateRecordingAddHLS(value: Boolean) {
        updateRecordingAddHls(value)
    }

    fun updateShowRecordButtons(value: Boolean) {
        if (showRecordButtons == value) return
        showRecordButtons = value
        parameters.updateShowRecordButtons(value)
        notifier()
    }

    fun updateRecordingProgressTime(value: String) {
        if (recordingProgressTime == value) return
        recordingProgressTime = value
        parameters.updateRecordingProgressTime(value)
        notifier()
    }

    fun updateRecordingAudioSupport(value: Boolean) {
        if (recordingAudioSupport == value) return
        recordingAudioSupport = value
        parameters.updateRecordingAudioSupport(value)
        notifier()
    }

    fun updateRecordingVideoSupport(value: Boolean) {
        if (recordingVideoSupport == value) return
        recordingVideoSupport = value
        parameters.updateRecordingVideoSupport(value)
        notifier()
    }

    fun updateRecordingAllParticipantsSupport(value: Boolean) {
        if (recordingAllParticipantsSupport == value) return
        recordingAllParticipantsSupport = value
        parameters.updateRecordingAllParticipantsSupport(value)
        notifier()
    }

    fun updateRecordingVideoParticipantsSupport(value: Boolean) {
        if (recordingVideoParticipantsSupport == value) return
        recordingVideoParticipantsSupport = value
        parameters.updateRecordingVideoParticipantsSupport(value)
        notifier()
    }

    fun updateCanRecord(value: Boolean) {
        if (canRecord == value) return
        canRecord = value
        parameters.updateCanRecord(value)
        notifier()
    }

    fun updateClearedToRecord(value: Boolean) {
        if (clearedToRecord == value) return
        clearedToRecord = value
        parameters.updateClearedToRecord(value)
        notifier()
    }

    fun toggleRecording() {
        val shouldStart = !recordStarted
        updateRecordStarted(shouldStart)
        if (shouldStart) {
            updateRecordStopped(false)
            updateRecordPaused(false)
            updateRecordResumed(false)
        } else {
            updateRecordPaused(false)
            updateRecordResumed(false)
            updateRecordStopped(true)
        }
    }

    fun updateRecordStarted(value: Boolean) {
        if (recordStarted == value) return
        recordStarted = value
        parameters.updateRecordStarted(value)
        refreshRecordState()
    }

    fun updateRecordPaused(value: Boolean) {
        if (recordPaused == value) return
        recordPaused = value
        parameters.updateRecordPaused(value)
        refreshRecordState()
    }

    fun updateRecordResumed(value: Boolean) {
        if (recordResumed == value) return
        recordResumed = value
        parameters.updateRecordResumed(value)
        // When something resumes, paused state naturally clears
        if (value) {
            recordPaused = false
            parameters.updateRecordPaused(false)
        }
        refreshRecordState()
    }

    fun updateRecordStopped(value: Boolean) {
        if (recordStopped == value) return
        recordStopped = value
        parameters.updateRecordStopped(value)
        refreshRecordState()
    }

    private fun refreshRecordState() {
        val newState = when {
            recordStarted && !recordStopped && recordPaused -> "yellow"
            recordStarted && !recordStopped -> "red"
            else -> "green"
        }
        if (recordState != newState) {
            recordState = newState
        }
        parameters.updateRecordState(newState)
        notifier()
    }

    fun refreshFromParameters() {
        recordingMediaOptions = parameters.recordingMediaOptions
        recordingAudioOptions = parameters.recordingAudioOptions
        recordingVideoOptions = parameters.recordingVideoOptions
        recordingVideoType = parameters.recordingVideoType
        recordingVideoOptimized = parameters.recordingVideoOptimized
        recordingDisplayType = parameters.recordingDisplayType
        recordingAddHLS = parameters.recordingAddHLS
        recordState = parameters.recordState
        showRecordButtons = parameters.showRecordButtons
        recordingProgressTime = parameters.recordingProgressTime
        recordStarted = parameters.recordStarted
        recordPaused = parameters.recordPaused
        recordResumed = parameters.recordResumed
        recordStopped = parameters.recordStopped
        recordingAudioSupport = parameters.recordingAudioSupport
        recordingVideoSupport = parameters.recordingVideoSupport
        recordingAllParticipantsSupport = parameters.recordingAllParticipantsSupport
        recordingVideoParticipantsSupport = parameters.recordingVideoParticipantsSupport
        canRecord = parameters.canRecord
        clearedToRecord = parameters.clearedToRecord
    }
}

class MeetingState(
    private val scope: CoroutineScope,
    private val parameters: MediasfuParameters,
    private val notifier: () -> Unit
) {
    var progressTime by mutableStateOf(formatElapsed(parameters.meetingElapsedTime))
        private set
    var isVisible by mutableStateOf(parameters.progressTimerVisible)
        private set

    private var timerJob: Job? = null

    init {
        if (parameters.isTimerRunning) {
            startTimer()
        } else {
            progressTime = formatElapsed(parameters.meetingElapsedTime)
        }
    }

    val isRunning: Boolean
        get() = timerJob?.isActive == true

    fun startTimer() {
        if (timerJob?.isActive == true) return
        timerJob = scope.launch {
            parameters.isTimerRunning = true
            var elapsedSeconds = parameters.meetingElapsedTime
            while (isActive) {
                progressTime = formatElapsed(elapsedSeconds)
                parameters.meetingProgressTime = progressTime
                parameters.meetingElapsedTime = elapsedSeconds
                notifier()
                delay(1000)
                elapsedSeconds += 1
            }
        }
        show()
    }

    fun pauseTimer() {
        if (timerJob?.isActive != true) return
        timerJob?.cancel()
        timerJob = null
        parameters.isTimerRunning = false
        notifier()
    }

    fun stopTimer(reset: Boolean = false) {
        timerJob?.cancel()
        timerJob = null
        parameters.isTimerRunning = false
        if (reset) {
            parameters.meetingElapsedTime = 0
            progressTime = formatElapsed(0)
            parameters.meetingProgressTime = progressTime
        }
        notifier()
    }

    fun resumeTimer() {
        if (timerJob?.isActive == true) return
        startTimer()
    }

    fun hide() {
        if (!isVisible) return
        isVisible = false
        parameters.progressTimerVisible = false
        notifier()
    }

    fun show() {
        if (isVisible) return
        isVisible = true
        parameters.progressTimerVisible = true
        notifier()
    }

    fun toggleVisibility() {
        if (isVisible) hide() else show()
    }

    private fun formatElapsed(seconds: Int): String {
        val hours = seconds / 3600
        val minutes = (seconds % 3600) / 60
        val secs = seconds % 60
        return String.format("%02d:%02d:%02d", hours, minutes, secs)
    }
}

class MessagingState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    val messages = mutableStateListOf<Message>().apply { addAll(parameters.messages) }
    var startDirectMessage by mutableStateOf(parameters.startDirectMessage)
    var directMessageDetails by mutableStateOf(parameters.directMessageDetails)
    var showMessagesBadge by mutableStateOf(parameters.showMessagesBadge)

    fun append(message: Message) {
        messages.add(message)
        parameters.messages = messages.toList()
        showMessagesBadge = true
        parameters.showMessagesBadge = true
        notifier()
    }

    fun clearBadge() {
        if (!showMessagesBadge) return
        showMessagesBadge = false
        parameters.showMessagesBadge = false
        notifier()
    }

    fun updateMessages(newMessages: List<Message>) {
        messages.clear()
        messages.addAll(newMessages)
        parameters.messages = newMessages
        notifier()
    }

    fun updateShowMessagesBadge(show: Boolean) {
        if (showMessagesBadge == show) return
        showMessagesBadge = show
        parameters.showMessagesBadge = show
        notifier()
    }
}

class WaitingRoomState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    var filter by mutableStateOf(parameters.waitingRoomFilter)
    val waitingRoomList = mutableStateListOf<WaitingRoomParticipant>().apply {
        addAll(parameters.waitingRoomList)
    }
    val filteredWaitingRoomList = mutableStateListOf<WaitingRoomParticipant>().apply {
        addAll(parameters.filteredWaitingRoomList.ifEmpty { parameters.waitingRoomList })
    }
    var counter by mutableStateOf(parameters.waitingRoomCounter)

    fun updateList(list: List<WaitingRoomParticipant>) {
        waitingRoomList.clear()
        waitingRoomList.addAll(list)
        parameters.waitingRoomList = list
        updateFilteredList()
    }

    fun updateFilteredList() {
        val newList = if (filter.isBlank()) waitingRoomList else waitingRoomList.filter {
            it.name.contains(filter, ignoreCase = true)
        }
        filteredWaitingRoomList.clear()
        filteredWaitingRoomList.addAll(newList)
        counter = newList.size
        parameters.filteredWaitingRoomList = newList
        parameters.waitingRoomCounter = counter
        notifier()
    }
}

class RequestsState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    var filter by mutableStateOf(parameters.requestFilter)
    val requests = mutableStateListOf<Request>().apply { addAll(parameters.requestList) }
    val filteredRequests = mutableStateListOf<Request>().apply {
        addAll(parameters.filteredRequestList.ifEmpty { parameters.requestList })
    }
    var counter by mutableStateOf(parameters.requestCounter)
    var totalPending by mutableStateOf(parameters.totalReqWait)

    fun updateList(list: List<Request>) {
        requests.clear()
        requests.addAll(list)
        parameters.requestList = list
        updateFilteredList()
    }

    fun updateFilteredList() {
        val newList = if (filter.isBlank()) requests else requests.filter {
            it.name?.contains(filter, ignoreCase = true) == true
        }
        filteredRequests.clear()
        filteredRequests.addAll(newList)
        counter = newList.size
        parameters.filteredRequestList = newList
        parameters.requestCounter = counter
        notifier()
    }

    fun updateTotalPending(value: Int) {
        if (totalPending == value) return
        totalPending = value
        parameters.totalReqWait = value
        notifier()
    }

    fun refreshFromParameters() {
        val newTotal = parameters.totalReqWait
        if (totalPending != newTotal) {
            totalPending = newTotal
        }
    }

    // Action update methods
    fun updateMicAction(action: Boolean) {
        parameters.micAction = action
        notifier()
    }

    fun updateVideoAction(action: Boolean) {
        parameters.videoAction = action
        notifier()
    }

    fun updateScreenAction(action: Boolean) {
        parameters.screenAction = action
        notifier()
    }

    fun updateChatAction(action: Boolean) {
        parameters.chatAction = action
        notifier()
    }

    // Request state update methods
    fun updateAudioRequestState(state: String) {
        parameters.audioRequestState = state
        notifier()
    }

    fun updateVideoRequestState(state: String) {
        parameters.videoRequestState = state
        notifier()
    }

    fun updateScreenRequestState(state: String) {
        parameters.screenRequestState = state
        notifier()
    }

    fun updateChatRequestState(state: String) {
        parameters.chatRequestState = state
        notifier()
    }

    // Request time update methods
    fun updateAudioRequestTime(time: Long?) {
        parameters.audioRequestTime = time
        notifier()
    }

    fun updateVideoRequestTime(time: Long?) {
        parameters.videoRequestTime = time
        notifier()
    }

    fun updateScreenRequestTime(time: Long?) {
        parameters.screenRequestTime = time
        notifier()
    }

    fun updateChatRequestTime(time: Long?) {
        parameters.chatRequestTime = time
        notifier()
    }
}

class PollsState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    val polls = mutableStateListOf<Poll>().apply { addAll(parameters.polls) }
    var activePoll by mutableStateOf(parameters.poll)
        private set
    var isPollModalVisible by mutableStateOf(parameters.isPollModalVisible)
        private set

    // Alias for activePoll to match Flutter/React naming
    val poll: Poll? get() = activePoll

    fun updatePolls(newPolls: List<Poll>) {
        if (polls == newPolls) return
        polls.syncWith(newPolls)
        parameters.polls = newPolls
        notifier()
    }

    fun updatePoll(poll: Poll) {
        if (activePoll == poll) return
        activePoll = poll
        parameters.poll = poll
        notifier()
    }

    fun clearActivePoll() {
        if (activePoll == null) return
        activePoll = null
        parameters.poll = null
        notifier()
    }

    fun setPollModalVisibility(visible: Boolean) {
        if (isPollModalVisible == visible) return
        isPollModalVisible = visible
        parameters.isPollModalVisible = visible
        notifier()
    }

    fun updateIsPollModalVisible(visible: Boolean) {
        setPollModalVisibility(visible)
    }

    fun refreshFromParameters() {
        polls.syncWith(parameters.polls)
        if (activePoll != parameters.poll) {
            activePoll = parameters.poll
        }
        if (isPollModalVisible != parameters.isPollModalVisible) {
            isPollModalVisible = parameters.isPollModalVisible
        }
    }

    private fun MutableList<Poll>.syncWith(values: List<Poll>) {
        if (this == values) return
        clear()
        addAll(values)
    }
}

class BreakoutState(private val parameters: MediasfuParameters, private val notifier: () -> Unit) {
    val breakoutRooms = mutableStateListOf<List<ModelBreakoutParticipant>>().apply {
        addAll(parameters.breakoutRooms)
    }
    var canStartBreakout by mutableStateOf(parameters.canStartBreakout)
    var breakOutRoomStarted by mutableStateOf(parameters.breakOutRoomStarted)
    var breakOutRoomEnded by mutableStateOf(parameters.breakOutRoomEnded)
    var currentRoomIndex by mutableStateOf(parameters.currentRoomIndex)

    fun updateRooms(rooms: List<List<ModelBreakoutParticipant>>) {
        breakoutRooms.clear()
        breakoutRooms.addAll(rooms)
        parameters.breakoutRooms = rooms
        notifier()
    }

    fun updateBreakoutRooms(rooms: List<List<ModelBreakoutParticipant>>) {
        updateRooms(rooms)
    }

    fun updateBreakOutRoomStarted(value: Boolean) {
        if (breakOutRoomStarted == value) return
        breakOutRoomStarted = value
        parameters.breakOutRoomStarted = value
        notifier()
    }

    fun updateBreakOutRoomEnded(value: Boolean) {
        if (breakOutRoomEnded == value) return
        breakOutRoomEnded = value
        parameters.breakOutRoomEnded = value
        notifier()
    }

    fun updateCurrentRoomIndex(index: Int) {
        if (currentRoomIndex == index) return
        currentRoomIndex = index
        parameters.currentRoomIndex = index
        notifier()
    }

    fun updateCanStartBreakout(value: Boolean) {
        if (canStartBreakout == value) return
        canStartBreakout = value
        parameters.canStartBreakout = value
        notifier()
    }
}

class ModalState(
    private val parameters: MediasfuParameters, 
    private val notifier: () -> Unit,
    private val coroutineScope: CoroutineScope
) {
    var isMenuVisible by mutableStateOf(parameters.isMenuModalVisible)
    var isRecordingVisible by mutableStateOf(parameters.isRecordingModalVisible)
    var isSettingsVisible by mutableStateOf(parameters.isSettingsModalVisible)
    var isRequestsVisible by mutableStateOf(parameters.isRequestsModalVisible)
    var isWaitingVisible by mutableStateOf(parameters.isWaitingModalVisible)
    var isCoHostVisible by mutableStateOf(parameters.isCoHostModalVisible)
    var isMediaSettingsVisible by mutableStateOf(parameters.isMediaSettingsModalVisible)
    var isDisplaySettingsVisible by mutableStateOf(parameters.isDisplaySettingsModalVisible)
    var isParticipantsVisible by mutableStateOf(parameters.isParticipantsModalVisible)
    var isMessagesVisible by mutableStateOf(parameters.isMessagesModalVisible)
    var isConfirmExitVisible by mutableStateOf(parameters.isConfirmExitModalVisible)
    var isConfirmHereVisible by mutableStateOf(parameters.isConfirmHereModalVisible)
    var isShareEventVisible by mutableStateOf(parameters.isShareEventModalVisible)
    var isLoadingVisible by mutableStateOf(parameters.isLoadingModalVisible)
    var isScreenboardVisible by mutableStateOf(parameters.isScreenboardModalVisible)
    var isBreakoutRoomsVisible by mutableStateOf(parameters.isBreakoutRoomsModalVisible)

    fun closeAll() {
        isMenuVisible = false
        isRecordingVisible = false
        isSettingsVisible = false
        isRequestsVisible = false
        isWaitingVisible = false
        isCoHostVisible = false
        isMediaSettingsVisible = false
        isDisplaySettingsVisible = false
        isParticipantsVisible = false
        isMessagesVisible = false
        isConfirmExitVisible = false
        isConfirmHereVisible = false
        isShareEventVisible = false
        isLoadingVisible = false
        isScreenboardVisible = false
        parameters.isMenuModalVisible = false
        parameters.isRecordingModalVisible = false
        parameters.isSettingsModalVisible = false
        parameters.isRequestsModalVisible = false
        parameters.isWaitingModalVisible = false
        parameters.isCoHostModalVisible = false
        parameters.isMediaSettingsModalVisible = false
        parameters.isDisplaySettingsModalVisible = false
        parameters.isParticipantsModalVisible = false
        parameters.isMessagesModalVisible = false
        parameters.isConfirmExitModalVisible = false
        parameters.isConfirmHereModalVisible = false
        parameters.isShareEventModalVisible = false
        parameters.isLoadingModalVisible = false
        parameters.isScreenboardModalVisible = false
        parameters.isBreakoutRoomsModalVisible = false
        notifier()
    }

    fun setMenuVisibility(visible: Boolean) {
        if (isMenuVisible == visible) return
        isMenuVisible = visible
        parameters.isMenuModalVisible = visible
        notifier()
    }

    fun setRecordingVisibility(visible: Boolean) {
        if (isRecordingVisible == visible) return
        isRecordingVisible = visible
        parameters.isRecordingModalVisible = visible
        notifier()
    }

    fun setLoadingVisibility(visible: Boolean) {
        if (isLoadingVisible == visible) return
        isLoadingVisible = visible
        parameters.isLoadingModalVisible = visible
        notifier()
    }

    fun setRequestsVisibility(visible: Boolean) {
        if (isRequestsVisible == visible) return
        isRequestsVisible = visible
        parameters.isRequestsModalVisible = visible
        notifier()
    }

    fun showRequests() {
        if (isRequestsVisible) return
        closeAll()
        setRequestsVisibility(true)
    }

    fun setWaitingVisibility(visible: Boolean) {
        if (isWaitingVisible == visible) return
        isWaitingVisible = visible
        parameters.isWaitingModalVisible = visible
        notifier()
    }

    fun showWaiting() {
        if (isWaitingVisible) return
        closeAll()
        setWaitingVisibility(true)
    }

    fun showParticipants() {
        closeAll()
        isParticipantsVisible = true
        parameters.isParticipantsModalVisible = true
        notifier()
    }

    fun showMessages() {
        closeAll()
        isMessagesVisible = true
        parameters.isMessagesModalVisible = true
        notifier()
    }

    fun showSettings() {
        closeAll()
        setSettingsVisibility(true)
    }

    fun setSettingsVisibility(visible: Boolean) {
        if (isSettingsVisible == visible) return
        isSettingsVisible = visible
        parameters.isSettingsModalVisible = visible
        notifier()
    }

    fun showShareEvent() {
        closeAll()
        setShareEventVisibility(true)
    }

    fun setShareEventVisibility(visible: Boolean) {
        if (isShareEventVisible == visible) return
        isShareEventVisible = visible
        parameters.isShareEventModalVisible = visible
        notifier()
    }

    fun showConfirmExit() {
        closeAll()
        setConfirmExitVisibility(true)
    }

    fun setConfirmExitVisibility(visible: Boolean) {
        if (isConfirmExitVisible == visible) return
        isConfirmExitVisible = visible
        parameters.isConfirmExitModalVisible = visible
        notifier()
    }

    fun setConfirmHereVisibility(visible: Boolean) {
        if (isConfirmHereVisible == visible) return
        isConfirmHereVisible = visible
        parameters.isConfirmHereModalVisible = visible
        notifier()
    }

    fun updateIsConfirmHereModalVisible(visible: Boolean) {
        setConfirmHereVisibility(visible)
    }

    fun showConfirmHere() {
        closeAll()
        setConfirmHereVisibility(true)
    }

    fun setScreenboardVisibility(visible: Boolean) {
        if (isScreenboardVisible == visible) return
        isScreenboardVisible = visible
        parameters.isScreenboardModalVisible = visible
        notifier()
    }

    fun updateIsPollModalVisible(visible: Boolean) {
        parameters.isPollModalVisible = visible
        notifier()
    }

    fun showRecording() {
        closeAll()
        setRecordingVisibility(true)
    }

    fun showCoHost() {
        closeAll()
        isCoHostVisible = true
        parameters.isCoHostModalVisible = true
        notifier()
    }

    fun showMediaSettings() {
        coroutineScope.launch {
            try {
                // Close other modals first
                closeAll()
                
                // Launch media settings (requests permissions and enumerates devices)
                // Note: launchMediaSettings handles modal visibility toggle at the end
                launchMediaSettings(
                    LaunchMediaSettingsOptions(
                        updateIsMediaSettingsModalVisible = { value ->
                            isMediaSettingsVisible = value
                            parameters.isMediaSettingsModalVisible = value
                            notifier()
                        },
                        isMediaSettingsModalVisible = isMediaSettingsVisible,
                        // Convert from model.MediaDeviceInfo to webrtc.MediaDeviceInfo
                        audioInputs = parameters.audioInputs.map { modelDevice ->
                            com.mediasfu.sdk.webrtc.MediaDeviceInfo(
                                deviceId = modelDevice.deviceId,
                                label = modelDevice.label,
                                kind = modelDevice.kind.toString(), // Convert enum to String
                                groupId = modelDevice.groupId
                            )
                        },
                        videoInputs = parameters.videoInputs.map { modelDevice ->
                            com.mediasfu.sdk.webrtc.MediaDeviceInfo(
                                deviceId = modelDevice.deviceId,
                                label = modelDevice.label,
                                kind = modelDevice.kind.toString(), // Convert enum to String
                                groupId = modelDevice.groupId
                            )
                        },
                        updateAudioInputs = { inputs ->
                            // Convert from webrtc.MediaDeviceInfo to model.MediaDeviceInfo
                            parameters.audioInputs = inputs.map { webrtcDevice ->
                                val kindStr = webrtcDevice.kind ?: "audioinput"
                                val kind = when (kindStr.lowercase()) {
                                    "audioinput" -> com.mediasfu.sdk.model.MediaDeviceKind.AUDIOINPUT
                                    "audiooutput" -> com.mediasfu.sdk.model.MediaDeviceKind.AUDIOOUTPUT
                                    "videoinput" -> com.mediasfu.sdk.model.MediaDeviceKind.VIDEOINPUT
                                    else -> com.mediasfu.sdk.model.MediaDeviceKind.AUDIOINPUT
                                }
                                com.mediasfu.sdk.model.MediaDeviceInfo(
                                    deviceId = webrtcDevice.deviceId ?: "",
                                    label = webrtcDevice.label ?: "",
                                    kind = kind,
                                    groupId = webrtcDevice.groupId ?: ""
                                )
                            }
                            notifier()
                        },
                        updateVideoInputs = { inputs ->
                            // Convert from webrtc.MediaDeviceInfo to model.MediaDeviceInfo
                            parameters.videoInputs = inputs.map { webrtcDevice ->
                                val kindStr = webrtcDevice.kind ?: "videoinput"
                                val kind = when (kindStr.lowercase()) {
                                    "audioinput" -> com.mediasfu.sdk.model.MediaDeviceKind.AUDIOINPUT
                                    "audiooutput" -> com.mediasfu.sdk.model.MediaDeviceKind.AUDIOOUTPUT
                                    "videoinput" -> com.mediasfu.sdk.model.MediaDeviceKind.VIDEOINPUT
                                    else -> com.mediasfu.sdk.model.MediaDeviceKind.VIDEOINPUT
                                }
                                com.mediasfu.sdk.model.MediaDeviceInfo(
                                    deviceId = webrtcDevice.deviceId ?: "",
                                    label = webrtcDevice.label ?: "",
                                    kind = kind,
                                    groupId = webrtcDevice.groupId ?: ""
                                )
                            }
                            notifier()
                        },
                        videoAlreadyOn = parameters.videoAlreadyOn,
                        audioAlreadyOn = parameters.audioAlreadyOn,
                        onWeb = false, // We're on mobile
                        updateIsLoadingModalVisible = { /* Can optionally show loading */ },
                        device = parameters.device  // Pass the device with context
                    )
                )
                // Don't call closeAll() here - launchMediaSettings handles modal visibility
            } catch (e: Exception) {
                println("Error launching media settings: ${e.message}")
            }
        }
    }

    fun showDisplaySettings() {
        closeAll()
        isDisplaySettingsVisible = true
        parameters.isDisplaySettingsModalVisible = true
        notifier()
    }

    fun toggleCoHost() {
        isCoHostVisible = !isCoHostVisible
        parameters.isCoHostModalVisible = isCoHostVisible
        notifier()
    }

    fun toggleMediaSettings() {
        isMediaSettingsVisible = !isMediaSettingsVisible
        parameters.isMediaSettingsModalVisible = isMediaSettingsVisible
        notifier()
    }

    fun toggleDisplaySettings() {
        isDisplaySettingsVisible = !isDisplaySettingsVisible
        parameters.isDisplaySettingsModalVisible = isDisplaySettingsVisible
        notifier()
    }

    fun toggleBreakoutRooms() {
        isBreakoutRoomsVisible = !isBreakoutRoomsVisible
        parameters.isBreakoutRoomsModalVisible = isBreakoutRoomsVisible
        notifier()
    }

    fun updateIsMediaSettingsVisible(visible: Boolean) {
        if (isMediaSettingsVisible == visible) return
        isMediaSettingsVisible = visible
        parameters.isMediaSettingsModalVisible = visible
        notifier()
    }

    fun updateIsDisplaySettingsVisible(visible: Boolean) {
        if (isDisplaySettingsVisible == visible) return
        isDisplaySettingsVisible = visible
        parameters.isDisplaySettingsModalVisible = visible
        notifier()
    }

    fun updateIsCoHostVisible(visible: Boolean) {
        if (isCoHostVisible == visible) return
        isCoHostVisible = visible
        parameters.isCoHostModalVisible = visible
        notifier()
    }

    fun updateIsCoHostModalVisible(visible: Boolean) {
        updateIsCoHostVisible(visible)
    }

    fun updateIsBreakoutRoomsModalVisible(visible: Boolean) {
        if (isBreakoutRoomsVisible == visible) return
        isBreakoutRoomsVisible = visible
        parameters.isBreakoutRoomsModalVisible = visible
        notifier()
    }
}

class AlertState(private val parameters: MediasfuParameters) {
    var visible by mutableStateOf(parameters.alertVisible)
        private set
    var message by mutableStateOf(parameters.alertMessage)
        private set
    var type by mutableStateOf(parameters.alertType)
        private set
    var duration by mutableStateOf(parameters.alertDuration)
        private set

    fun show(message: String, type: String, duration: Int) {
        this.visible = true
        this.message = message
        this.type = type
        this.duration = duration
    }

    fun hide() {
        visible = false
    }
}

data class MediasfuGenericOptions(
    val preJoinPage: (@Composable (MediasfuGenericState) -> Unit)? = null,
    val localLink: String = "",
    val connectMediaSFU: Boolean = true,
    val credentials: Credentials? = null,
    val useLocalUIMode: Boolean? = null,
    val seedData: ModelSeedData? = null,
    val useSeed: Boolean? = null,
    val imgSrc: String? = null,
    val sourceParameters: MediasfuParameters? = null,
    val updateSourceParameters: ((MediasfuParameters) -> Unit)? = null,
    val returnUI: Boolean = true,
    val noUIPreJoinOptionsCreate: Map<String, Any>? = null,
    val noUIPreJoinOptionsJoin: Map<String, Any>? = null,
    val joinMediaSFURoom: suspend (JoinRoomClientOptions) -> ResponseJoinRoom = { joinRoomClient(it) },
    val createMediaSFURoom: suspend (JoinRoomClientOptions) -> ResponseJoinRoom = { joinRoomClient(it) },
    val customVideoCard: (@Composable (Stream) -> Unit)? = null,
    val customAudioCard: (@Composable (Stream) -> Unit)? = null,
    val customMiniCard: (@Composable (Stream) -> Unit)? = null,
    val customComponent: (@Composable (MediasfuGenericState) -> Unit)? = null,
    val uiOverrides: MediasfuUiOverrides = MediasfuUiOverrides()
)

@Composable
fun rememberMediasfuGenericState(options: MediasfuGenericOptions): MediasfuGenericState {
    val scope = rememberCoroutineScope()
    val parameters = remember(options) { options.sourceParameters ?: MediasfuParameters() }
    val state = remember(options, parameters) {
        MediasfuGenericState(scope = scope, parameters = parameters, options = options)
    }

    LaunchedEffect(state.parameters) {
        options.updateSourceParameters?.invoke(state.parameters)
    }

    DisposableEffect(state) {
        onDispose {
            state.parameters.onParticipantsUpdated = null
        }
    }

    return state
}

@Composable
fun MediasfuGeneric(
    options: MediasfuGenericOptions,
    modifier: Modifier = Modifier,
    state: MediasfuGenericState = rememberMediasfuGenericState(options),
) {
    MediasfuGenericContent(state = state, modifier = modifier)
}

// ---------------------------------------------------------------------------
// Compose UI
// ---------------------------------------------------------------------------

private data class ControlButtonModel(
    val label: String,
    val icon: ImageVector,
    val onClick: () -> Unit,
    val alternateIcon: ImageVector? = null,
    val isActive: Boolean = false,
    val isEnabled: Boolean = true,
    val isVisible: Boolean = true,
    val activeTint: Color = Color(0xFF40C4FF),
    val inactiveTint: Color = Color(0xFF90A4AE),
    val textColor: Color = Color.White,
    val badgeText: String? = null,
    val badgeColor: Color = Color(0xFFFF4D4F)
)

/**
 * Converts ControlButtonModel to ControlButtonOptions for use with ControlButtonsComponentTouch
 */
private fun ControlButtonModel.toControlButtonOptions(): ControlButtonOptions {
    // Convert androidx.compose.ui.graphics.Color to com.mediasfu.sdk.ui.Color
    fun androidx.compose.ui.graphics.Color.toMediaSfuColor(): com.mediasfu.sdk.ui.Color {
        return com.mediasfu.sdk.ui.Color(
            red = this.red,
            green = this.green,
            blue = this.blue,
            alpha = this.alpha
        )
    }
    
    return ControlButtonOptions(
        id = label.lowercase().replace(" ", "_"),
        text = label,
        icon = null, // Icons are handled differently in Compose
        active = isActive,
        enabled = isEnabled,
        visible = isVisible,
        textColor = textColor.toMediaSfuColor(),
        activeColor = activeTint.toMediaSfuColor(),
        inactiveColor = inactiveTint.toMediaSfuColor(),
        onClick = onClick
    )
}

/**
 * Converts list of ControlButtonModel to ControlButtonOptions
 */
private fun List<ControlButtonModel>.toControlButtonOptions(): List<ControlButtonOptions> {
    return this.map { it.toControlButtonOptions() }
}

@Composable
private fun ControlButtonsRow(
    buttons: List<ControlButtonModel>,
    modifier: Modifier = Modifier
) {
    val visibleButtons = remember(buttons) { buttons.filter(ControlButtonModel::isVisible) }
    if (visibleButtons.isEmpty()) return

    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.SpaceEvenly,
        verticalAlignment = Alignment.CenterVertically
    ) {
        visibleButtons.forEach { button ->
            ControlButtonItem(button)
        }
    }
}

@Composable
private fun ControlButtonItem(button: ControlButtonModel) {
    val iconTint = if (button.isActive) button.activeTint else button.inactiveTint
    val iconVector = if (button.isActive && button.alternateIcon != null) {
        button.alternateIcon
    } else {
        button.icon
    }
    val adjustedIconTint = if (button.isEnabled) iconTint else iconTint.copy(alpha = 0.4f)
    val labelColor = if (button.isEnabled) button.textColor else button.textColor.copy(alpha = 0.6f)

    Column(
        modifier = Modifier
            .clickable(enabled = button.isEnabled) { button.onClick() }
            .padding(horizontal = 12.dp, vertical = 8.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center
    ) {
        Box(
            modifier = Modifier.size(36.dp),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                iconVector,
                contentDescription = button.label,
                tint = adjustedIconTint,
                modifier = Modifier.size(28.dp)
            )
            if (button.badgeText != null) {
                Box(
                    modifier = Modifier
                        .align(Alignment.TopEnd)
                        .background(button.badgeColor, CircleShape)
                        .size(12.dp),
                    contentAlignment = Alignment.Center
                ) {
                    if (button.badgeText.isNotEmpty()) {
                        Text(
                            text = button.badgeText,
                            color = Color.White,
                            fontSize = 8.sp,
                            textAlign = TextAlign.Center
                        )
                    }
                }
            }
        }
        Spacer(modifier = Modifier.height(4.dp))
        Text(text = button.label, color = labelColor, fontSize = 12.sp)
    }
}

@Composable
private fun MediasfuGenericContent(state: MediasfuGenericState, modifier: Modifier = Modifier) {
    val isValidated by state.validated.collectAsState()
    val isLoading by state.isLoading.collectAsState()
    val hasAlert by remember { derivedStateOf { state.alert.visible } }

    // Wrap everything in a Box so we can layer components
    Box(modifier = modifier.fillMaxSize()) {
        // Main content box
        Box(modifier = Modifier.fillMaxSize().background(Color(0xFF0B172A))) {
            if (!isValidated) {
                PreJoinOrWelcome(state)
            } else {
                EventRoom(state)
            }

            if (isLoading) {
                LoadingOverlay()
            }
        }

        // Modals (these render on their own layer with AlertDialog)
        MenuModal(state)
        RecordingModal(state)
        RequestsModal(state)
        WaitingModal(state)
        DisplaySettingsModal(state)
        CoHostModal(state)
        MediaSettingsModal(state)
        BreakoutRoomsModal(state)
        PollModal(state)
        ParticipantsModal(state)
        MessagesModal(state)
        SettingsModal(state)
        ShareEventModal(state)
        ConfirmExitModal(state)
        ConfirmHereModal(state)
        LoadingModal(state)
        
        // Alert banner - rendered LAST so it's on top of everything (including modals)
        AlertBanner(
            state = state,
            isVisible = hasAlert,
            modifier = Modifier
                .padding(16.dp)
                .align(Alignment.TopCenter)
        )
    }
}

// Primary control buttons helper function
private fun MediasfuGenericState.primaryControlButtons(): List<ControlButtonModel> {
    val mediaState = media
    val recordingState = recording
    val messagingState = messaging
    val participantsCount = room.participantsCounter
    val requestCount = requests.totalPending
    val activePollCount = polls.polls.count { it.status.equals("active", ignoreCase = true) }

    val recordingSupported = recordingState.recordingAudioSupport || recordingState.recordingVideoSupport
    val recordingButtonEnabled = recordingSupported && recordingState.canRecord && parameters.canLaunchRecord

    val participantsBadge = participantsCount.takeIf { it > 0 }?.let { count ->
        when {
            count > 99 -> "99+"
            else -> count.toString()
        }
    }
    val requestsBadge = requestCount.takeIf { it > 0 }?.let { count ->
        when {
            count > 99 -> "99+"
            else -> count.toString()
        }
    }
    val pollBadge = activePollCount.takeIf { it > 0 }?.let { it.toString() }

    return listOf(
        ControlButtonModel(
            label = if (mediaState.audioAlreadyOn) "Mute" else "Unmute",
            icon = Icons.Rounded.MicOff,
            alternateIcon = Icons.Rounded.Mic,
            isActive = mediaState.audioAlreadyOn,
            onClick = { toggleAudio() },
            activeTint = Color(0xFF52C41A)
        ),
        ControlButtonModel(
            label = if (mediaState.videoAlreadyOn) "Stop Video" else "Video",
            icon = Icons.Rounded.VideoCall,
            alternateIcon = Icons.Rounded.VideoCameraFront,
            isActive = mediaState.videoAlreadyOn,
            onClick = { toggleVideo() }
        ),
        ControlButtonModel(
            label = if (mediaState.screenAlreadyOn) "Stop Share" else "Share",
            icon = Icons.AutoMirrored.Rounded.ScreenShare,
            alternateIcon = Icons.AutoMirrored.Rounded.StopScreenShare,
            isActive = mediaState.screenAlreadyOn,
            onClick = { toggleScreenShare() },
            activeTint = Color(0xFFFAAD14)
        ),
        ControlButtonModel(
            label = "People",
            icon = Icons.Rounded.Group,
            onClick = { openParticipants() },
            badgeText = participantsBadge
        ),
        ControlButtonModel(
            label = "Menu",
            icon = Icons.Rounded.Menu,
            onClick = { toggleMenu() },
            badgeText = requestsBadge
        ),
        ControlButtonModel(
            label = "Chat",
            icon = Icons.AutoMirrored.Rounded.Chat,
            onClick = { openMessages() },
            badgeText = if (messagingState.showMessagesBadge) "" else null
        ),
        ControlButtonModel(
            label = if (recordingState.recordStarted) "Stop Rec" else "Record",
            icon = Icons.Rounded.VideoCall,
            onClick = { toggleRecording() },
            isActive = recordingState.recordStarted,
            activeTint = Color(0xFFFF4D4F),
            isEnabled = recordingButtonEnabled,
            isVisible = recordingSupported
        ),
        ControlButtonModel(
            label = "Polls",
            icon = Icons.Rounded.HowToVote,
            onClick = { togglePollModal() },
            badgeText = pollBadge
        ),
        ControlButtonModel(
            label = "Settings",
            icon = Icons.Rounded.Settings,
            onClick = { openSettings() }
        ),
        ControlButtonModel(
            label = "Exit",
            icon = Icons.Rounded.Close,
            onClick = { openConfirmExit() },
            activeTint = Color(0xFFFF4D4F),
            inactiveTint = Color(0xFFFF4D4F)
        )
    )
}

@Composable
private fun PreJoinOrWelcome(state: MediasfuGenericState) {
    val options = state.options
    if (options.preJoinPage != null && options.credentials != null && options.credentials.apiKey.isNotBlank()) {
        options.preJoinPage.invoke(state)
    } else {
        WelcomePage(state)
    }
}

@OptIn(ExperimentalMaterial3Api::class)
@Composable
private fun WelcomePage(state: MediasfuGenericState) {
    // This function is too long to include inline - will be added in next step
    Box(modifier = Modifier.fillMaxSize().background(Color(0xFF0B172A))) {
        Text("Welcome Page Placeholder", color = Color.White, modifier = Modifier.align(Alignment.Center))
    }
}

@Composable
private fun EventRoom(state: MediasfuGenericState) {
    // Determine streams to display
    val display = state.display
    val streams = state.streams
    val room = state.room
    val participants = room.participants.toList()
    val participantList by remember { derivedStateOf { participants } }
    val showPagination = display.doPaginate && streams.paginatedStreams.size > 1

    val placeholderStreams = remember(participants) {
        buildPlaceholderStreams(participants)
    }

    val paginatedStreamsForPage = if (showPagination && display.currentUserPage < streams.paginatedStreams.size) {
        streams.paginatedStreams.elementOrNull(display.currentUserPage)?.toList().orEmpty()
    } else {
        emptyList()
    }
    val activeMainStreams = when {
        paginatedStreamsForPage.isNotEmpty() -> paginatedStreamsForPage
        streams.lStreams.isNotEmpty() -> streams.lStreams.toList()
        streams.currentStreams.isNotEmpty() -> streams.currentStreams.toList()
        else -> emptyList()
    }
    val displayMainStreams = if (activeMainStreams.isNotEmpty()) activeMainStreams else placeholderStreams

    // Determine mini view streams
    val miniViewStreams = when {
        streams.mixedAlVideoStreams.isNotEmpty() -> streams.mixedAlVideoStreams.toList()
        streams.nonAlVideoStreams.isNotEmpty() -> streams.nonAlVideoStreams.toList()
        display.showMiniView && activeMainStreams.size > 1 -> activeMainStreams.drop(1)
        placeholderStreams.size > 1 -> placeholderStreams.drop(1)
        display.showMiniView && placeholderStreams.isNotEmpty() -> placeholderStreams.take(1)
        display.showMiniView && displayMainStreams.isNotEmpty() -> listOf(displayMainStreams.first())
        else -> emptyList()
    }

    // Convert streams to display components
    val mainGridComponents = remember(displayMainStreams, participantList, state.parameters.audioDecibels) {
        displayMainStreams.toDisplayComponents(
            participants = participants,
            audioDecibels = state.parameters.audioDecibels.toList(),
            isVideoCard = true,
            showControls = false
        )
    }
    
    val miniViewComponents = remember(miniViewStreams, participantList, state.parameters.audioDecibels) {
        miniViewStreams.toDisplayComponents(
            participants = participants,
            audioDecibels = state.parameters.audioDecibels.toList(),
            isVideoCard = false, // Use MiniCard for mini view
            showControls = false
        )
    }

    Column(
        modifier = Modifier
            .fillMaxWidth()
            .background(Color(0xFF101B2D))
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        if (state.options.customComponent != null) {
            state.options.customComponent.invoke(state)
        } else {
            val mainContainerComponent = remember {
                DefaultMainContainerComponent(
                    MainContainerComponentOptions(
                        backgroundColor = 0xFF172645.toInt(),
                        padding = 16
                    )
                )
            }

            val mainAspectComponent = remember {
                DefaultMainAspectComponent(
                    MainAspectComponentOptions(
                        backgroundColor = 0xFF172645.toInt(),
                        defaultFraction = 1.0 - display.controlHeight,
                        showControls = state.room.eventType != EventType.WEBINAR && state.room.eventType != EventType.CONFERENCE,
                        updateIsWideScreen = display::setWideScreenFlag,
                        updateIsMediumScreen = display::setMediumScreenFlag,
                        updateIsSmallScreen = display::setSmallScreenFlag
                    )
                )
            }

            val mainScreenComponent = remember(display.mainHeightWidth) {
                DefaultMainScreenComponent(
                    MainScreenComponentOptions(
                        backgroundColor = 0xFF172645.toInt(),
                        mainSize = display.mainHeightWidth,
                        showAspect = true
                    )
                )
            }

            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .clip(RoundedCornerShape(16.dp))
                    .background(Color(0xFF172645))
            ) {
                mainContainerComponent.renderCompose {
                    mainAspectComponent.renderCompose {
                        Box(modifier = Modifier.fillMaxWidth()) {
                            mainScreenComponent.renderCompose {
                                BoxWithConstraints(modifier = Modifier.fillMaxWidth()) {
                                    val density = LocalDensity.current
                                    val maxWidthDp = maxWidth
                                    val resolvedHeightDp = when {
                                        maxHeight == Dp.Infinity || maxHeight == Dp.Unspecified -> maxWidthDp * (9f / 16f)
                                        else -> maxHeight
                                    }.coerceAtLeast(240.dp)

                                    val mainGridWidthDp = maxWidthDp
                                    val mainGridHeightDp = (resolvedHeightDp * 0.7f).coerceAtLeast(160.dp)
                                    val miniGridHeightDp = (resolvedHeightDp * 0.3f).coerceAtLeast(96.dp)

                                    val mainGridWidth = mainGridWidthDp.value.roundToInt().coerceAtLeast(100)
                                    val mainGridHeight = mainGridHeightDp.value.roundToInt().coerceAtLeast(100)
                                    val miniGridHeight = miniGridHeightDp.value.roundToInt().coerceAtLeast(80)

                                    LaunchedEffect(maxWidthDp, resolvedHeightDp, showPagination) {
                                        val widthPx = with(density) { maxWidthDp.toPx() }
                                        val heightPx = with(density) { resolvedHeightDp.toPx() }

                                        if (widthPx.isFinite() && heightPx.isFinite()) {
                                            val wideThreshold = with(density) { 768.dp.toPx() }
                                            val mediumThreshold = with(density) { 576.dp.toPx() }

                                            val isWide = widthPx > wideThreshold
                                            val isMedium = widthPx > mediumThreshold && widthPx <= wideThreshold
                                            val isSmall = widthPx <= mediumThreshold

                                            display.setWideScreenFlag(isWide)
                                            display.setMediumScreenFlag(isMedium)
                                            display.setSmallScreenFlag(isSmall)

                                            display.updateComponentSizes(
                                                ComponentSizes(
                                                    otherWidth = widthPx.toDouble(),
                                                    otherHeight = with(density) { miniGridHeightDp.toPx() }.toDouble()
                                                )
                                            )
                                            display.updateMainHeightWidth(heightPx.toDouble())
                                        }
                                    }

                                    val flexGrid = remember(mainGridComponents, display.gridRows, display.gridCols, mainGridWidth, mainGridHeight) {
                                        DefaultFlexibleGrid(
                                            FlexibleGridOptions(
                                                customWidth = mainGridWidth,
                                                customHeight = mainGridHeight,
                                                rows = display.gridRows,
                                                columns = display.gridCols,
                                                componentsToRender = mainGridComponents,
                                                backgroundColor = 0xFF172645.toInt(),
                                                showAspect = true
                                            )
                                        )
                                    }

                                    val miniGridWidth = mainGridWidthDp.value.roundToInt().coerceAtLeast(100)
                                    val otherFlexGrid = remember(miniViewComponents, display.altGridRows, display.altGridCols, miniGridWidth, miniGridHeight) {
                                        DefaultFlexibleGrid(
                                            FlexibleGridOptions(
                                                customWidth = miniGridWidth,
                                                customHeight = miniGridHeight,
                                                rows = display.altGridRows,
                                                columns = display.altGridCols,
                                                componentsToRender = miniViewComponents,
                                                backgroundColor = 0xFF0F1A2D.toInt(),
                                                showAspect = true
                                            )
                                        )
                                    }

                                    // Trigger updateMiniCardsGrid when mini-view changes
                                    LaunchedEffect(miniViewComponents.size, display.componentSizes) {
                                        if (miniViewComponents.isNotEmpty() && display.componentSizes.otherWidth > 0.0) {
                                            val computedCols = sqrt(miniViewComponents.size.toDouble()).let { ceil(it).toInt() }.coerceAtLeast(1)
                                            val computedRows = ((miniViewComponents.size + computedCols - 1) / computedCols).coerceAtLeast(1)
                                            
                                            updateMiniCardsGridImpl(
                                                rows = computedRows,
                                                cols = computedCols,
                                                defal = false,
                                                actualRows = computedRows,
                                                gridSizes = display.gridSizes,
                                                paginationDirection = display.paginationDirection,
                                                paginationHeightWidth = display.paginationHeightWidth,
                                                doPaginate = display.doPaginate,
                                                componentSizes = display.componentSizes,
                                                eventType = state.room.eventType.name,
                                                updateGridRows = display::updateGridRows,
                                                updateGridCols = display::updateGridCols,
                                                updateAltGridRows = display::updateAltGridRows,
                                                updateAltGridCols = display::updateAltGridCols,
                                                updateGridSizes = display::updateGridSizes
                                            )
                                        }
                                    }

                                    Column(
                                        modifier = Modifier.fillMaxWidth(),
                                        verticalArrangement = Arrangement.spacedBy(12.dp)
                                    ) {
                                        val mainGridComponent = remember(mainGridComponents, mainGridWidth, mainGridHeight, display.mainHeightWidth, state.meeting.isVisible) {
                                            DefaultMainGridComponent(
                                                MainGridComponentOptions(
                                                    height = mainGridHeight,
                                                    width = mainGridWidth,
                                                    backgroundColor = 0xFF172645.toInt(),
                                                    mainSize = display.mainHeightWidth,
                                                    showAspect = true,
                                                    timeBackgroundColor = 0xFF2E7D32.toInt(),
                                                    showTimer = state.meeting.isVisible
                                                )
                                            )
                                        }

                                        val timerSlot: @Composable BoxScope.() -> Unit = {
                                            MeetingProgressTimerBadge(
                                                state = state,
                                                modifier = Modifier
                                                    .align(Alignment.TopEnd)
                                                    .padding(12.dp)
                                            )
                                        }

                                        mainGridComponent.renderCompose(
                                            renderTimer = state.meeting.isVisible,
                                            timer = if (state.meeting.isVisible) timerSlot else null
                                        ) {
                                            if (mainGridComponents.isNotEmpty()) {
                                                flexGrid.renderCompose()
                                            } else {
                                                Box(
                                                    modifier = Modifier
                                                        .fillMaxSize()
                                                        .clip(RoundedCornerShape(12.dp))
                                                        .background(Color(0xFF1C2B4A)),
                                                    contentAlignment = Alignment.Center
                                                ) {
                                                    Text(
                                                        text = "Waiting for streams...",
                                                        color = Color.White.copy(alpha = 0.7f),
                                                        fontSize = 14.sp,
                                                        fontWeight = FontWeight.Medium
                                                    )
                                                }
                                            }
                                        }

                                        // SubAspect - wraps mini-view and controls (matches React/Flutter)
                                        if (display.showMiniView) {
                                            val subAspectComponent = remember {
                                                DefaultSubAspectComponent(
                                                    SubAspectComponentOptions(
                                                        backgroundColor = 0xFF0F1A2D.toInt(),
                                                        showControls = state.room.eventType != EventType.WEBINAR,
                                                        defaultFraction = 0.3
                                                    )
                                                )
                                            }

                                            Box(
                                                modifier = Modifier
                                                    .fillMaxWidth()
                                                    .clip(RoundedCornerShape(12.dp))
                                                    .background(Color(0xFF0F1A2D))
                                                    .padding(12.dp)
                                            ) {
                                                Column(
                                                    modifier = Modifier.fillMaxWidth(),
                                                    verticalArrangement = Arrangement.spacedBy(8.dp)
                                                ) {
                                                    // Other Grid (mini-view)
                                                    val otherGridComponent = remember(miniViewComponents, miniGridWidth, miniGridHeight, display.altGridRows, display.altGridCols) {
                                                        DefaultOtherGridComponent(
                                                            OtherGridComponentOptions(
                                                                height = miniGridHeight,
                                                                width = miniGridWidth,
                                                                backgroundColor = 0xFF0F1A2D.toInt(),
                                                                gridSize = display.altGridRows.toDouble(),
                                                                showAspect = true
                                                            )
                                                        )
                                                    }

                                                    otherGridComponent.renderCompose {
                                                        Text(
                                                            text = "Mini view",
                                                            color = Color.White.copy(alpha = 0.8f),
                                                            fontSize = 13.sp,
                                                            fontWeight = FontWeight.SemiBold
                                                        )
                                                        Spacer(modifier = Modifier.height(8.dp))
                                                        if (miniViewComponents.isNotEmpty()) {
                                                            otherFlexGrid.renderCompose()
                                                        } else {
                                                            Box(
                                                                modifier = Modifier
                                                                    .fillMaxWidth()
                                                                    .heightIn(min = 72.dp)
                                                                    .clip(RoundedCornerShape(10.dp))
                                                                    .background(Color(0xFF162544)),
                                                                contentAlignment = Alignment.Center
                                                            ) {
                                                                Text(
                                                                    text = "Waiting for more videos...",
                                                                    color = Color.White.copy(alpha = 0.7f),
                                                                    fontSize = 13.sp,
                                                                    fontWeight = FontWeight.Medium
                                                                )
                                                            }
                                                        }
                                                    }

                                                    // Control Buttons (inside SubAspect)
                                                    if (subAspectComponent.options.showControls) {
                                                        val controlButtons = remember(
                                                            state.media.audioAlreadyOn,
                                                            state.media.videoAlreadyOn,
                                                            state.media.screenAlreadyOn,
                                                            state.recording.recordStarted,
                                                            state.messaging.showMessagesBadge,
                                                            state.room.participantsCounter
                                                        ) { state.primaryControlButtons() }

                                                        val controlButtonOptions = remember(controlButtons) {
                                                            controlButtons.toControlButtonOptions()
                                                        }

                                                        val controlButtonsComponent = remember(controlButtonOptions) {
                                                            DefaultControlButtonsComponentTouch(
                                                                ControlButtonsComponentTouchOptions(
                                                                    buttons = controlButtonOptions,
                                                                    position = "bottom",
                                                                    direction = "horizontal",
                                                                    backgroundColor = 0x80172645.toInt(),
                                                                    buttonBackgroundColor = 0x401E88E5.toInt(),
                                                                    buttonSpacing = 12,
                                                                    buttonSize = 56
                                                                )
                                                            )
                                                        }
                                                        controlButtonsComponent.renderCompose()
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

private fun MediasfuGenericState.primaryControlButtons(): List<ControlButtonModel> {
    val mediaState = media
    val recordingState = recording
    val messagingState = messaging
    val participantsCount = room.participantsCounter
    val requestCount = requests.totalPending
    val activePollCount = polls.polls.count { it.status.equals("active", ignoreCase = true) }

    val recordingSupported = recordingState.recordingAudioSupport || recordingState.recordingVideoSupport
    val recordingButtonEnabled = recordingSupported && recordingState.canRecord && parameters.canLaunchRecord

    val participantsBadge = participantsCount.takeIf { it > 0 }?.let { count ->
        when {
            count > 99 -> "99+"
            else -> count.toString()
        }
    }
    val requestsBadge = requestCount.takeIf { it > 0 }?.let { count ->
        when {
            count > 99 -> "99+"
            else -> count.toString()
        }
    }
    val pollBadge = activePollCount.takeIf { it > 0 }?.let { it.toString() }

    return listOf(
        ControlButtonModel(
            label = if (mediaState.audioAlreadyOn) "Mute" else "Unmute",
            icon = Icons.Rounded.MicOff,
            alternateIcon = Icons.Rounded.Mic,
            isActive = mediaState.audioAlreadyOn,
            onClick = { toggleAudio() },
            activeTint = Color(0xFF52C41A)
        ),
        ControlButtonModel(
            label = if (mediaState.videoAlreadyOn) "Stop Video" else "Video",
            icon = Icons.Rounded.VideoCall,
            alternateIcon = Icons.Rounded.VideoCameraFront,
            isActive = mediaState.videoAlreadyOn,
            onClick = { toggleVideo() }
        ),
        ControlButtonModel(
            label = if (mediaState.screenAlreadyOn) "Stop Share" else "Share",
            icon = Icons.AutoMirrored.Rounded.ScreenShare,
            alternateIcon = Icons.AutoMirrored.Rounded.StopScreenShare,
            isActive = mediaState.screenAlreadyOn,
            onClick = { toggleScreenShare() },
            activeTint = Color(0xFFFAAD14)
        ),
        ControlButtonModel(
            label = "People",
            icon = Icons.Rounded.Group,
            onClick = { openParticipants() },
            badgeText = participantsBadge
        ),
        ControlButtonModel(
            label = "Menu",
            icon = Icons.Rounded.Menu,
            onClick = { toggleMenu() },
            badgeText = requestsBadge
        ),
        ControlButtonModel(
            label = "Chat",
            icon = Icons.AutoMirrored.Rounded.Chat,
            onClick = { openMessages() },
            badgeText = if (messagingState.showMessagesBadge) "" else null
        ),
        ControlButtonModel(
            label = if (recordingState.recordStarted) "Stop Rec" else "Record",
            icon = Icons.Rounded.VideoCall,
            onClick = { toggleRecording() },
            isActive = recordingState.recordStarted,
            activeTint = Color(0xFFFF4D4F),
            isEnabled = recordingButtonEnabled,
            isVisible = recordingSupported
        ),
        ControlButtonModel(
            label = "Polls",
            icon = Icons.Rounded.HowToVote,
            onClick = { togglePollModal() },
            badgeText = pollBadge
        ),
        ControlButtonModel(
            label = "Settings",
            icon = Icons.Rounded.Settings,
            onClick = { openSettings() }
        ),
        ControlButtonModel(
            label = "Exit",
            icon = Icons.Rounded.Close,
            onClick = { openConfirmExit() },
            activeTint = Color(0xFFFF4D4F),
            inactiveTint = Color(0xFFFF4D4F)
        )
    )
}

// Helper extension function for safe element access
private fun <T> SnapshotStateList<T>.elementOrNull(index: Int): T? =
    if (index in 0 until size) this[index] else null

@Composable
private fun LoadingOverlay() {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.Black.copy(alpha = 0.55f)),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator(color = Color.White)
    }
}

@Composable
private fun AlertBanner(state: MediasfuGenericState, isVisible: Boolean, modifier: Modifier = Modifier) {
    val alertState = state.alert
    
    val containerColor = when (alertState.type) {
        "danger", "error" -> Color(0xFFFF4D4F)
        "warning" -> Color(0xFFFFC53D)
        "success" -> Color(0xFF52C41A)
        else -> Color(0xFF1890FF)
    }

    LaunchedEffect(alertState.visible) {
        if (alertState.visible) {
            delay(alertState.duration.toLong())
            alertState.hide()
        }
    }

    AnimatedVisibility(
        visible = isVisible,
        enter = fadeIn(animationSpec = TweenSpec(durationMillis = 200)),
        exit = fadeOut(animationSpec = TweenSpec(durationMillis = 200)),
        modifier = modifier.fillMaxWidth()
    ) {
        ElevatedCard(
            colors = CardDefaults.elevatedCardColors(containerColor = containerColor),
            shape = RoundedCornerShape(12.dp)
        ) {
            Row(
                modifier = Modifier.padding(horizontal = 20.dp, vertical = 16.dp),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column(
                    modifier = Modifier.fillMaxWidth(0.85f),
                    verticalArrangement = Arrangement.spacedBy(4.dp)
                ) {
                    Text(
                        text = when (alertState.type) {
                            "danger", "error" -> "Alert"
                            "warning" -> "Warning"
                            "success" -> "Success"
                            else -> "Info"
                        },
                        style = MaterialTheme.typography.titleMedium,
                        color = Color.White,
                        fontWeight = FontWeight.Bold
                    )
                    Text(alertState.message, color = Color.White)
                }
                IconButton(onClick = alertState::hide) {
                    Icon(Icons.Rounded.Close, contentDescription = "Dismiss alert", tint = Color.White)
                }
            }
        }
    }
}

// ShareEventModal, ConfirmExitModal, and ConfirmHereModal already extracted to separate files

private val EVENT_SETTING_OPTIONS = listOf("allow", "approval", "disallow")
